# Linux 기초

> *"컨테이너는 마법이 아니다. 그것은 Linux 커널의 기능들을 영리하게 조합한 것이다."*
> — Jérôme Petazzoni, Docker 초기 개발자

컨테이너 기술의 핵심을 이해하려면 먼저 그 기반이 되는 Linux 커널의 핵심 개념들을 이해해야 합니다. 이 장에서는 네임스페이스와 cgroups를 중심으로 컨테이너를 가능하게 하는 Linux의 핵심 기술들을 깊이 있게 다룹니다.

---

## 이 장에서 다루는 내용

이 장을 읽고 나면 다음을 이해할 수 있습니다:

- **Linux 커널의 역할**: 운영체제의 핵심으로서 커널이 하는 일
- **프로세스 관리**: fork/exec 모델과 프로세스 상태
- **Linux 네임스페이스**: 7가지 네임스페이스 유형과 컨테이너 격리 원리
- **Control Groups (cgroups)**: 리소스 제한의 원리와 Kubernetes에서의 활용
- **파일 시스템과 마운트**: 오버레이 파일 시스템과 컨테이너 이미지
- **시스템 콜**: 사용자 공간과 커널 공간의 인터페이스

> **📘 개념 (Concept)**: 이 장의 모든 개념은 컨테이너 런타임(containerd, runc)이 실제로 사용하는 Linux 기능들입니다. 이를 이해하면 컨테이너 문제를 근본적으로 해결할 수 있습니다.

---

## 1. Linux 커널 개요

### 1.1. 커널이란 무엇인가?

커널(Kernel)은 운영체제의 핵심으로, 하드웨어와 소프트웨어 사이의 중재자 역할을 합니다. 모든 프로그램은 결국 커널을 통해 하드웨어 자원에 접근합니다.

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                           Linux 시스템 계층 구조                             │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   ┌─────────────────────────────────────────────────────────────────────┐  │
│   │                      User Space (사용자 공간)                        │  │
│   │                                                                       │  │
│   │  ┌───────────┐  ┌───────────┐  ┌───────────┐  ┌───────────┐        │  │
│   │  │ 애플리케이션│  │   셸     │  │  라이브러리 │  │  컨테이너  │        │  │
│   │  │ (nginx,   │  │ (bash,   │  │  (glibc,  │  │(containerd│        │  │
│   │  │  python)  │  │  zsh)    │  │   musl)   │  │  kubelet) │        │  │
│   │  └───────────┘  └───────────┘  └───────────┘  └───────────┘        │  │
│   │                                                                       │  │
│   │  Ring 3 (최소 권한) - 직접 하드웨어 접근 불가                          │  │
│   └─────────────────────────────────────────────────────────────────────┘  │
│                                    │                                       │
│                          System Call Interface                             │
│                    (시스템 콜: 유일한 커널 진입점)                           │
│                                    │                                       │
│   ┌─────────────────────────────────────────────────────────────────────┐  │
│   │                      Kernel Space (커널 공간)                        │  │
│   │                                                                       │  │
│   │  ┌─────────────────────────────────────────────────────────────────┐ │  │
│   │  │                        Linux Kernel                              │ │  │
│   │  │                                                                  │ │  │
│   │  │  ┌───────────┐  ┌───────────┐  ┌───────────┐  ┌───────────┐   │ │  │
│   │  │  │ 프로세스   │  │  메모리   │  │ 파일시스템 │  │  네트워크  │   │ │  │
│   │  │  │  관리     │  │   관리    │  │   (VFS)   │  │   스택    │   │ │  │
│   │  │  │           │  │           │  │           │  │           │   │ │  │
│   │  │  │• 스케줄러 │  │• 페이징   │  │• ext4     │  │• TCP/IP   │   │ │  │
│   │  │  │• 네임스페이스│ │• 캐싱    │  │• overlayfs│  │• Netfilter│   │ │  │
│   │  │  │• cgroups  │  │• OOM     │  │• proc/sys │  │• eBPF     │   │ │  │
│   │  │  └───────────┘  └───────────┘  └───────────┘  └───────────┘   │ │  │
│   │  │                                                                  │ │  │
│   │  │  ┌───────────┐  ┌───────────┐  ┌───────────┐  ┌───────────┐   │ │  │
│   │  │  │  보안     │  │   IPC    │  │  디바이스  │  │  시간     │   │ │  │
│   │  │  │           │  │          │  │  드라이버  │  │  관리     │   │ │  │
│   │  │  │• SELinux  │  │• 파이프  │  │• 블록     │  │• 타이머   │   │ │  │
│   │  │  │• AppArmor │  │• 소켓    │  │• 문자     │  │• 인터럽트 │   │ │  │
│   │  │  │• Seccomp  │  │• 공유메모리│ │• 네트워크 │  │           │   │ │  │
│   │  │  └───────────┘  └───────────┘  └───────────┘  └───────────┘   │ │  │
│   │  │                                                                  │ │  │
│   │  │  Ring 0 (최대 권한) - 모든 하드웨어 접근 가능                     │ │  │
│   │  └─────────────────────────────────────────────────────────────────┘ │  │
│   │                                                                       │  │
│   └─────────────────────────────────────────────────────────────────────┘  │
│                                    │                                       │
│   ┌─────────────────────────────────────────────────────────────────────┐  │
│   │                         Hardware (하드웨어)                          │  │
│   │       CPU        Memory        Disk        Network        I/O       │  │
│   └─────────────────────────────────────────────────────────────────────┘  │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

> **💡 팁 (Tip)**: 컨테이너는 "경량 가상머신"이 아닙니다. 컨테이너는 호스트 커널을 공유하며, 커널의 네임스페이스와 cgroups 기능을 사용해 격리를 구현합니다.

### 1.2. 커널의 핵심 서브시스템

| 서브시스템 | 역할 | 컨테이너에서의 활용 |
|-----------|------|-------------------|
| **프로세스 스케줄러** | CPU 시간 분배 | cgroups CPU 제한 |
| **메모리 관리** | 가상 메모리, 페이징 | cgroups 메모리 제한, OOM killer |
| **VFS (Virtual File System)** | 파일 시스템 추상화 | overlayfs (컨테이너 이미지) |
| **네트워크 스택** | TCP/IP, 소켓 | Network namespace, veth pair |
| **보안 모듈** | 접근 제어 | SELinux, AppArmor, Seccomp |

### 1.3. 커널 버전과 기능

```bash
# 커널 버전 확인
uname -r
# 출력 예: 6.12.0-0.rc0.20240918git4a4be1ad3e6d.fc42.x86_64

# 상세 커널 정보
cat /proc/version
# Linux version 6.12.0 (gcc 14.0.0) ...

# 커널 설정 확인 (cgroups v2 지원 여부)
cat /boot/config-$(uname -r) | grep CGROUP
```

> **📘 개념 (Concept)**: 커널 버전에 따라 사용 가능한 기능이 다릅니다. 특히 eBPF와 Cilium의 고급 기능은 최신 커널을 요구합니다.

**Kubernetes/Cilium 커널 요구사항:**

| 기능 | 최소 커널 | RHEL 10 (6.12) | 설명 |
|------|----------|----------------|------|
| Kubernetes 기본 | 3.10+ | ✅ 지원 | 기본 컨테이너 실행 |
| cgroups v2 | 4.15+ | ✅ 지원 | 통합 리소스 제어 |
| Cilium 기본 | 4.19+ | ✅ 지원 | eBPF 기본 기능 |
| eBPF 고급 기능 | 5.10+ | ✅ 지원 | BTF, CO-RE |
| Netkit 데이터패스 | 6.7+ | ✅ 지원 | 최적화된 Pod 네트워킹 |

---

## 2. 프로세스와 스레드

### 2.1. 프로세스의 정의

프로세스는 **실행 중인 프로그램의 인스턴스**입니다. 각 프로세스는 독립된 가상 메모리 공간과 시스템 리소스를 가집니다.

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                            프로세스 메모리 구조                              │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   가상 주소 공간 (64-bit 시스템 기준)                                        │
│                                                                             │
│   High Address (0x7FFFFFFFFFFF)                                             │
│   ┌─────────────────────────────────────────────────────────────────────┐  │
│   │                    Kernel Space (상위 절반)                          │  │
│   │                    사용자가 직접 접근 불가                            │  │
│   ├─────────────────────────────────────────────────────────────────────┤  │
│   │                                                                       │  │
│   │   ┌───────────────────────────────────────────────────────────────┐ │  │
│   │   │   Stack (스택)                                     ▼ 아래로 증가│ │  │
│   │   │   • 지역 변수, 함수 매개변수                                     │ │  │
│   │   │   • 함수 호출 시 스택 프레임 생성                                │ │  │
│   │   │   • 크기 제한 있음 (ulimit -s, 기본 8MB)                        │ │  │
│   │   └───────────────────────────────────────────────────────────────┘ │  │
│   │                              │                                       │  │
│   │                              │ (빈 공간 - 주소 공간 레이아웃 랜덤화)   │  │
│   │                              │                                       │  │
│   │   ┌───────────────────────────────────────────────────────────────┐ │  │
│   │   │   Memory Mapped Region                                         │ │  │
│   │   │   • 공유 라이브러리 (libc.so, ld-linux.so)                      │ │  │
│   │   │   • mmap으로 매핑된 파일                                        │ │  │
│   │   └───────────────────────────────────────────────────────────────┘ │  │
│   │                              │                                       │  │
│   │   ┌───────────────────────────────────────────────────────────────┐ │  │
│   │   │   Heap (힙)                                        ▲ 위로 증가 │ │  │
│   │   │   • 동적 메모리 할당 (malloc, new)                              │ │  │
│   │   │   • 프로그램 실행 중 크기 변경                                   │ │  │
│   │   └───────────────────────────────────────────────────────────────┘ │  │
│   │                                                                       │  │
│   │   ┌───────────────────────────────────────────────────────────────┐ │  │
│   │   │   BSS (Block Started by Symbol)                                │ │  │
│   │   │   • 초기화되지 않은 전역/정적 변수                               │ │  │
│   │   │   • 0으로 초기화됨                                              │ │  │
│   │   └───────────────────────────────────────────────────────────────┘ │  │
│   │                                                                       │  │
│   │   ┌───────────────────────────────────────────────────────────────┐ │  │
│   │   │   Data (데이터)                                                 │ │  │
│   │   │   • 초기화된 전역/정적 변수                                      │ │  │
│   │   │   • 읽기/쓰기 가능                                              │ │  │
│   │   └───────────────────────────────────────────────────────────────┘ │  │
│   │                                                                       │  │
│   │   ┌───────────────────────────────────────────────────────────────┐ │  │
│   │   │   Text (코드)                                                   │ │  │
│   │   │   • 실행 가능한 명령어                                          │ │  │
│   │   │   • 읽기 전용 (수정 불가)                                        │ │  │
│   │   └───────────────────────────────────────────────────────────────┘ │  │
│   │                                                                       │  │
│   └─────────────────────────────────────────────────────────────────────┘  │
│   Low Address (0x0)                                                         │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 2.2. fork/exec 모델

Linux에서 새 프로세스는 **fork(복제)** 후 **exec(교체)** 하는 방식으로 생성됩니다.

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                          fork() / exec() 동작 과정                           │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   1단계: fork() - 프로세스 복제                                              │
│   ─────────────────────────────────────────────────────────────────────     │
│                                                                             │
│   ┌─────────────────────┐                                                  │
│   │  Parent Process     │                                                  │
│   │  PID: 100           │                                                  │
│   │  Program: bash      │                                                  │
│   │                     │                                                  │
│   │  메모리 공간:        │                                                  │
│   │  [Code][Data][Heap] │                                                  │
│   │  [Stack]            │                                                  │
│   └──────────┬──────────┘                                                  │
│              │                                                              │
│              │ fork() 호출                                                  │
│              │                                                              │
│              ▼                                                              │
│   ┌─────────────────────┐        ┌─────────────────────┐                   │
│   │  Parent Process     │        │  Child Process      │                   │
│   │  PID: 100           │        │  PID: 101           │                   │
│   │  fork() 반환값: 101 │        │  fork() 반환값: 0   │                   │
│   │                     │        │  PPID: 100          │                   │
│   │  [Code][Data][Heap] │  복제  │  [Code][Data][Heap] │                   │
│   │  [Stack]            │ ─────► │  [Stack]            │                   │
│   └─────────────────────┘        └──────────┬──────────┘                   │
│                                             │                              │
│   2단계: exec() - 프로그램 교체 (자식에서)                                   │
│   ─────────────────────────────────────────────────────────────────────     │
│                                             │                              │
│                                             │ exec("nginx") 호출           │
│                                             │                              │
│                                             ▼                              │
│                                  ┌─────────────────────┐                   │
│                                  │  Child Process      │                   │
│                                  │  PID: 101 (동일)    │                   │
│                                  │  Program: nginx     │                   │
│                                  │                     │                   │
│                                  │  새로운 메모리 공간: │                   │
│                                  │  [nginx Code]       │                   │
│                                  │  [nginx Data/Heap]  │                   │
│                                  │  [nginx Stack]      │                   │
│                                  └─────────────────────┘                   │
│                                                                             │
│   핵심 포인트:                                                               │
│   • fork()는 PID만 다르고 나머지는 복제 (Copy-on-Write 최적화)               │
│   • exec()는 PID는 유지하고 메모리 내용만 교체                               │
│   • 컨테이너 런타임(runc)도 이 방식으로 컨테이너 프로세스 생성               │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

> **📝 예제 (Example)**: 컨테이너 생성 시 실제 동작
> ```
> containerd-shim (PID 1000)
>     │
>     └── fork() → containerd-shim (PID 1001)
>                      │
>                      └── clone(CLONE_NEWPID | CLONE_NEWNS | ...) 
>                           │
>                           └── exec("nginx") → nginx (컨테이너 내 PID 1)
> ```

### 2.3. 프로세스 상태 전이

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                          프로세스 상태 전이 다이어그램                        │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│                            fork()                                           │
│                              │                                              │
│                              ▼                                              │
│                     ┌─────────────────┐                                    │
│                     │    Created      │                                    │
│                     │    (생성됨)      │                                    │
│                     └────────┬────────┘                                    │
│                              │ 초기화 완료                                  │
│                              ▼                                              │
│   ┌──────────────────────────────────────────────────────────────────┐     │
│   │                                                                    │     │
│   │  ┌─────────────────┐      스케줄러      ┌─────────────────┐      │     │
│   │  │    Running      │◄────────────────►│     Ready       │      │     │
│   │  │    (실행 중)     │    CPU 할당/해제   │  (실행 대기)     │      │     │
│   │  │    [R 상태]      │                  │    [R 상태]      │      │     │
│   │  └────────┬────────┘                  └────────┬────────┘      │     │
│   │           │                                    │                │     │
│   └───────────┼────────────────────────────────────┼────────────────┘     │
│               │                                    │                       │
│               │                                    │                       │
│      I/O 요청 │    ┌─────────────────┐            │ I/O 완료              │
│      시그널   │    │   Sleeping      │            │ 시그널 수신            │
│      대기     └───►│   (대기 중)      │────────────┘                       │
│                    │                 │                                     │
│                    │  [S: 인터럽트 가능]                                    │
│                    │  [D: 디스크 I/O 대기]                                  │
│                    └────────┬────────┘                                     │
│                             │                                              │
│               ┌─────────────┴─────────────┐                               │
│               │                           │                               │
│               ▼                           ▼                               │
│   ┌─────────────────┐         ┌─────────────────┐                        │
│   │    Stopped      │         │    Zombie       │                        │
│   │   (정지됨)       │         │   (좀비)        │                        │
│   │   [T 상태]       │         │   [Z 상태]       │                        │
│   │                 │         │                 │                        │
│   │ SIGSTOP 수신    │         │ exit() 호출     │                        │
│   │ SIGCONT로 재개  │         │ 부모의 wait()   │                        │
│   └─────────────────┘         │ 대기 중         │                        │
│                               └────────┬────────┘                        │
│                                        │ 부모가 wait() 호출               │
│                                        ▼                                  │
│                               ┌─────────────────┐                        │
│                               │   Terminated    │                        │
│                               │   (종료됨)       │                        │
│                               │   자원 해제 완료 │                        │
│                               └─────────────────┘                        │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

> **⚠️ 주의 (Warning)**: D 상태(Uninterruptible Sleep)의 프로세스는 kill -9로도 종료할 수 없습니다. 이는 주로 디스크 I/O나 NFS 대기 중에 발생하며, 해당 I/O가 완료되어야 상태가 변경됩니다.

```bash
# 프로세스 상태 확인
ps aux | head -5
# USER  PID %CPU %MEM    VSZ   RSS TTY  STAT START   TIME COMMAND
# root    1  0.0  0.1 171256 13456 ?    Ss   09:00   0:01 /usr/lib/systemd/systemd

# STAT 컬럼 해석:
# S = Sleeping (인터럽트 가능한 대기)
# R = Running (실행 중 또는 실행 대기)
# D = Disk sleep (인터럽트 불가능한 대기)
# T = Stopped (정지됨)
# Z = Zombie (좀비)
# s = session leader
# + = foreground process group

# 특정 상태의 프로세스만 찾기
ps aux | awk '$8 ~ /D/'  # D 상태 (디스크 대기)
ps aux | awk '$8 ~ /Z/'  # Z 상태 (좀비)
```

### 2.4. 프로세스 vs 스레드

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                          프로세스 vs 스레드                                  │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   프로세스 (Process)                    스레드 (Thread)                     │
│   ┌─────────────────────┐              ┌─────────────────────┐             │
│   │  Process A (PID 100)│              │  Process B (PID 200)│             │
│   │                     │              │                     │             │
│   │  ┌───────────────┐  │              │  ┌───────────────┐  │             │
│   │  │   Code        │  │              │  │   Code        │  │             │
│   │  │   (독립)      │  │              │  │   (공유)      │  │             │
│   │  ├───────────────┤  │              │  ├───────────────┤  │             │
│   │  │   Data        │  │              │  │   Data        │  │             │
│   │  │   (독립)      │  │              │  │   (공유)      │  │             │
│   │  ├───────────────┤  │              │  ├───────────────┤  │             │
│   │  │   Heap        │  │              │  │   Heap        │  │             │
│   │  │   (독립)      │  │              │  │   (공유)      │  │             │
│   │  ├───────────────┤  │              │  ├─────┬───┬─────┤  │             │
│   │  │   Stack       │  │              │  │Stack│   │Stack│  │             │
│   │  │   (독립)      │  │              │  │ T1  │...│ Tn  │  │             │
│   │  └───────────────┘  │              │  │독립 │   │독립 │  │             │
│   │                     │              │  └─────┴───┴─────┘  │             │
│   └─────────────────────┘              └─────────────────────┘             │
│                                                                             │
│   ┌───────────────────┬───────────────────┬───────────────────────────────┐│
│   │      항목         │     프로세스      │          스레드              ││
│   ├───────────────────┼───────────────────┼───────────────────────────────┤│
│   │ 메모리 공간       │ 독립 (격리됨)      │ 프로세스 내 공유             ││
│   │ 생성 비용         │ 높음 (fork)       │ 낮음 (clone)                 ││
│   │ 컨텍스트 스위칭   │ 비쌈 (TLB flush)  │ 저렴 (같은 주소 공간)        ││
│   │ 통신 방법         │ IPC (파이프, 소켓) │ 직접 메모리 공유             ││
│   │ 장애 영향         │ 독립적            │ 전체 프로세스 영향           ││
│   │ 디버깅            │ 상대적으로 쉬움    │ 동기화 이슈로 어려움         ││
│   │ 컨테이너에서      │ 각 컨테이너       │ 컨테이너 내부                 ││
│   └───────────────────┴───────────────────┴───────────────────────────────┘│
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

> **📘 개념 (Concept)**: Linux에서 스레드는 `clone()` 시스템 콜로 생성되며, 프로세스와 동일한 `task_struct`로 표현됩니다. 이를 "경량 프로세스(LWP)"라고도 합니다. 커널 관점에서 프로세스와 스레드의 차이는 주소 공간을 공유하는지 여부입니다.

---

## 3. Linux 네임스페이스

### 3.1. 네임스페이스란?

네임스페이스는 프로세스에게 **격리된 시스템 리소스 뷰**를 제공하는 Linux 커널 기능입니다. 이는 컨테이너 기술의 핵심 기반입니다.

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                     네임스페이스: 컨테이너 격리의 핵심                        │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   "네임스페이스 = 시스템 리소스의 가상화된 뷰"                                │
│                                                                             │
│   호스트 시스템 (실제 리소스)                                                │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                                                                       │   │
│  │  • PID: 1, 2, 3, ... 100, 101, 200, 201, 202 ...                    │   │
│  │  • Network: eth0 (192.168.1.100), eth1, docker0, veth123...         │   │
│  │  • Mounts: /, /home, /var, /run/containerd/...                      │   │
│  │  • Users: root(0), user1(1000), user2(1001)...                      │   │
│  │  • Hostname: host-server-01                                          │   │
│  │                                                                       │   │
│  │      ┌─────────────────────────┐   ┌─────────────────────────┐       │   │
│  │      │     Container A         │   │     Container B         │       │   │
│  │      │    (격리된 네임스페이스)  │   │    (격리된 네임스페이스)  │       │   │
│  │      │                         │   │                         │       │   │
│  │      │  보이는 PID: 1, 2       │   │  보이는 PID: 1, 2, 3    │       │   │
│  │      │  (실제: 100, 101)       │   │  (실제: 200, 201, 202)  │       │   │
│  │      │                         │   │                         │       │   │
│  │      │  보이는 NIC: eth0       │   │  보이는 NIC: eth0       │       │   │
│  │      │  (10.200.0.5)           │   │  (10.200.0.6)           │       │   │
│  │      │                         │   │                         │       │   │
│  │      │  보이는 FS: / (overlayfs)│  │  보이는 FS: / (overlayfs)│       │   │
│  │      │                         │   │                         │       │   │
│  │      │  보이는 User: root(0)   │   │  보이는 User: root(0)   │       │   │
│  │      │  (실제: user1(1000))    │   │  (실제: user2(1001))    │       │   │
│  │      │                         │   │                         │       │   │
│  │      │  Hostname: container-a  │   │  Hostname: container-b  │       │   │
│  │      └─────────────────────────┘   └─────────────────────────┘       │   │
│  │                                                                       │   │
│  │      각 컨테이너는 자신만의 격리된 환경을 봄                            │   │
│  │      하지만 모두 같은 커널 위에서 실행됨                                │   │
│  │                                                                       │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 3.2. 8가지 네임스페이스 유형

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                          Linux 네임스페이스 유형                             │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ 네임스페이스    │ Clone 플래그      │ 격리 대상                      │   │
│  ├─────────────────────────────────────────────────────────────────────┤   │
│  │ PID            │ CLONE_NEWPID     │ 프로세스 ID 공간               │   │
│  │ Network        │ CLONE_NEWNET     │ 네트워크 장치, IP, 라우팅      │   │
│  │ Mount          │ CLONE_NEWNS      │ 파일 시스템 마운트 포인트      │   │
│  │ UTS            │ CLONE_NEWUTS     │ 호스트명, 도메인명             │   │
│  │ IPC            │ CLONE_NEWIPC     │ System V IPC, POSIX MQ        │   │
│  │ User           │ CLONE_NEWUSER    │ UID/GID 매핑                  │   │
│  │ Cgroup         │ CLONE_NEWCGROUP  │ cgroup 루트 디렉토리          │   │
│  │ Time (5.6+)    │ CLONE_NEWTIME    │ 시스템 시계 (부트/단조 시간)   │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  컨테이너 런타임(runc)이 사용하는 주요 네임스페이스:                          │
│  • PID: 컨테이너 내부에서 PID 1 부터 시작                                   │
│  • Network: 독립된 네트워크 스택 (IP, 라우팅, iptables)                     │
│  • Mount: 컨테이너 이미지를 루트로 마운트                                   │
│  • UTS: 컨테이너별 호스트명 설정                                           │
│  • IPC: 프로세스 간 통신 격리                                              │
│  • User: Rootless 컨테이너 지원                                            │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 3.3. PID 네임스페이스 심화

PID 네임스페이스는 프로세스 ID를 격리합니다. 각 PID 네임스페이스에서 프로세스는 PID 1부터 시작합니다.

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                         PID 네임스페이스 계층 구조                            │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   Host PID Namespace (Initial/Root namespace)                               │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                                                                       │   │
│  │  PID 1: systemd (init 프로세스)                                       │   │
│  │    │                                                                  │   │
│  │    ├── PID 500: containerd                                            │   │
│  │    │     │                                                            │   │
│  │    │     ├── PID 1000: containerd-shim (nginx 컨테이너용)              │   │
│  │    │     │     │                                                      │   │
│  │    │     │     └────┐                                                 │   │
│  │    │     │          │                                                 │   │
│  │    │     │   ┌──────▼────────────────────────────────────────┐       │   │
│  │    │     │   │  Container PID Namespace (nginx)              │       │   │
│  │    │     │   │                                                │       │   │
│  │    │     │   │  PID 1: nginx (master)                        │       │   │
│  │    │     │   │    ├── PID 2: nginx (worker)                  │       │   │
│  │    │     │   │    └── PID 3: nginx (worker)                  │       │   │
│  │    │     │   │                                                │       │   │
│  │    │     │   │  컨테이너 내부: ps aux → PID 1, 2, 3           │       │   │
│  │    │     │   │  호스트:       ps aux → PID 1001, 1002, 1003   │       │   │
│  │    │     │   └────────────────────────────────────────────────┘       │   │
│  │    │     │                                                            │   │
│  │    │     ├── PID 2000: containerd-shim (redis 컨테이너용)              │   │
│  │    │     │     │                                                      │   │
│  │    │     │     └────┐                                                 │   │
│  │    │     │          │                                                 │   │
│  │    │     │   ┌──────▼────────────────────────────────────────┐       │   │
│  │    │     │   │  Container PID Namespace (redis)              │       │   │
│  │    │     │   │                                                │       │   │
│  │    │     │   │  PID 1: redis-server                          │       │   │
│  │    │     │   │                                                │       │   │
│  │    │     │   │  호스트에서 보이는 PID: 2001                    │       │   │
│  │    │     │   └────────────────────────────────────────────────┘       │   │
│  │    │     │                                                            │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│   핵심 개념:                                                                 │
│   • 자식 PID NS는 부모 PID NS를 볼 수 없음                                  │
│   • 부모 PID NS는 자식 PID NS의 프로세스를 볼 수 있음 (다른 PID로)          │
│   • 컨테이너 내 PID 1이 죽으면 컨테이너 전체가 종료됨                        │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

> **⚠️ 주의 (Warning)**: 컨테이너의 PID 1 프로세스는 특별합니다. 이 프로세스가 종료되면 컨테이너 전체가 종료됩니다. 또한 고아(orphan) 프로세스의 부모가 됩니다. 따라서 컨테이너의 메인 프로세스는 시그널을 적절히 처리해야 합니다.

```bash
# PID 네임스페이스 실습

# 1. 새 PID 네임스페이스에서 bash 실행
sudo unshare --pid --fork --mount-proc bash

# 2. 새 네임스페이스 내에서 프로세스 확인
ps aux
# PID 1로 bash가 보임

# 3. 다른 터미널에서 호스트 관점의 PID 확인
ps aux | grep "unshare\|bash"
# 실제 PID는 훨씬 큰 숫자

# 4. 네임스페이스 ID 확인
ls -la /proc/self/ns/pid
# 호스트와 다른 inode 번호
```

### 3.4. Network 네임스페이스 심화

Network 네임스페이스는 완전히 독립된 네트워크 스택을 제공합니다.

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    Network 네임스페이스와 veth pair                          │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   Host Network Namespace                                                    │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                                                                       │   │
│  │   Physical NIC                         Linux Bridge (docker0)        │   │
│  │  ┌─────────────┐                      ┌─────────────────────────┐   │   │
│  │  │    eth0     │                      │       172.17.0.1        │   │   │
│  │  │192.168.1.100│                      │                         │   │   │
│  │  └──────┬──────┘                      │  ┌───────┐  ┌───────┐  │   │   │
│  │         │                              │  │veth-A │  │veth-B │  │   │   │
│  │         │                              │  │ (host)│  │ (host)│  │   │   │
│  │         │                              │  └───┬───┘  └───┬───┘  │   │   │
│  │         │                              └──────┼──────────┼──────┘   │   │
│  │         │                                     │          │          │   │
│  │         │                              veth pair   veth pair       │   │
│  │         │                               (가상 케이블)                 │   │
│  │         │                                     │          │          │   │
│  │   ──────┼─────────────────────────────────────┼──────────┼──────   │   │
│  │         │                                     │          │          │   │
│  │         │                              ┌──────▼───┐  ┌───▼──────┐   │   │
│  │         │                              │Container │  │Container │   │   │
│  │         │                              │ A NetNS  │  │ B NetNS  │   │   │
│  │         │                              │          │  │          │   │   │
│  │         │                              │ eth0     │  │ eth0     │   │   │
│  │         │                              │172.17.0.2│  │172.17.0.3│   │   │
│  │         │                              │          │  │          │   │   │
│  │         │                              │ 라우팅:   │  │ 라우팅:   │   │   │
│  │         │                              │ default  │  │ default  │   │   │
│  │         │                              │ via .0.1 │  │ via .0.1 │   │   │
│  │         │                              │          │  │          │   │   │
│  │         │                              │iptables: │  │iptables: │   │   │
│  │         │                              │ 독립     │  │ 독립     │   │   │
│  │         │                              └──────────┘  └──────────┘   │   │
│  │         │                                                           │   │
│  │   NAT (iptables MASQUERADE)                                         │   │
│  │   172.17.0.0/16 → 192.168.1.100 (외부 통신 시)                       │   │
│  │                                                                       │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│   각 Network Namespace가 가지는 독립 요소:                                  │
│   • 네트워크 인터페이스 (eth0, lo)                                         │
│   • IP 주소 및 라우팅 테이블                                               │
│   • iptables/nftables 규칙                                                 │
│   • 소켓 및 포트 바인딩                                                    │
│   • /proc/net/* 정보                                                       │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

> **📝 예제 (Example)**: Network 네임스페이스 생성 및 통신 설정

```bash
# 1. 네트워크 네임스페이스 생성
sudo ip netns add container1

# 2. veth pair 생성
sudo ip link add veth-host type veth peer name veth-container

# 3. veth-container를 네임스페이스로 이동
sudo ip link set veth-container netns container1

# 4. 호스트 측 veth 설정
sudo ip addr add 10.0.0.1/24 dev veth-host
sudo ip link set veth-host up

# 5. 컨테이너 측 veth 설정 (네임스페이스 내에서)
sudo ip netns exec container1 ip addr add 10.0.0.2/24 dev veth-container
sudo ip netns exec container1 ip link set veth-container up
sudo ip netns exec container1 ip link set lo up

# 6. 통신 테스트
ping 10.0.0.2  # 호스트 → 컨테이너
sudo ip netns exec container1 ping 10.0.0.1  # 컨테이너 → 호스트

# 7. 네임스페이스 내 네트워크 상태 확인
sudo ip netns exec container1 ip addr
sudo ip netns exec container1 ip route
sudo ip netns exec container1 ss -tlnp

# 8. 정리
sudo ip netns delete container1
```

### 3.5. Mount 네임스페이스

Mount 네임스페이스는 파일 시스템 마운트 포인트를 격리합니다.

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                         Mount 네임스페이스                                   │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   Host Mount Namespace                   Container Mount Namespace          │
│  ┌───────────────────────────┐          ┌───────────────────────────┐      │
│  │                           │          │                           │      │
│  │  /                        │          │  / (overlayfs)            │      │
│  │  ├── /bin                 │          │  ├── /bin (이미지 레이어)  │      │
│  │  ├── /etc                 │          │  ├── /etc (이미지 레이어)  │      │
│  │  │   └── /etc/hosts       │          │  │   └── /etc/hosts       │      │
│  │  ├── /home                │          │  │       (컨테이너 전용)   │      │
│  │  ├── /var                 │          │  ├── /var                 │      │
│  │  │   ├── /var/lib         │          │  │   └── /var/log         │      │
│  │  │   │   └── containerd/  │          │  │       (컨테이너 레이어) │      │
│  │  │   └── /var/log         │          │  ├── /app                 │      │
│  │  ├── /proc (procfs)       │          │  │   (볼륨 바인드 마운트)  │      │
│  │  ├── /sys (sysfs)         │          │  ├── /proc (컨테이너용)    │      │
│  │  └── /run                 │          │  └── /sys (제한된 뷰)      │      │
│  │      └── /run/containerd  │          │                           │      │
│  │          └── container-   │          │  마운트 플래그:            │      │
│  │              bundles/     │          │  • MS_PRIVATE             │      │
│  │                           │          │  • MS_SLAVE               │      │
│  └───────────────────────────┘          └───────────────────────────┘      │
│                                                                             │
│   컨테이너 이미지의 마운트 구조 (overlayfs):                                 │
│                                                                             │
│   ┌─────────────────────────────────────────────────────────────────────┐  │
│   │                                                                       │  │
│   │  Merged (컨테이너가 보는 뷰)                                          │  │
│   │  └── /merged/                                                        │  │
│   │      ├── bin/  ─┐                                                    │  │
│   │      ├── etc/   │ Lower에서 옴 (읽기 전용)                            │  │
│   │      ├── lib/  ─┘                                                    │  │
│   │      └── app/  ─── Upper에서 옴 (쓰기 가능)                           │  │
│   │                                                                       │  │
│   │  Upper (컨테이너 쓰기 레이어)    Work (overlayfs 작업용)               │  │
│   │  └── /upper/                   └── /work/                            │  │
│   │      └── app/new-file                                                │  │
│   │                                                                       │  │
│   │  Lower (이미지 레이어들, 읽기 전용)                                    │  │
│   │  ├── /layer3/  (애플리케이션)                                        │  │
│   │  ├── /layer2/  (의존성)                                              │  │
│   │  └── /layer1/  (베이스 이미지)                                        │  │
│   │                                                                       │  │
│   └─────────────────────────────────────────────────────────────────────┘  │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 3.6. User 네임스페이스 (Rootless 컨테이너)

User 네임스페이스는 UID/GID를 매핑하여 **루트 권한 없이 컨테이너를 실행**할 수 있게 합니다.

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    User 네임스페이스와 UID 매핑                              │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   Rootless 컨테이너의 UID 매핑                                              │
│                                                                             │
│   Host (Root namespace)              Container (User namespace)            │
│  ┌───────────────────────┐          ┌───────────────────────┐             │
│  │                       │          │                       │             │
│  │  UID 1000 (user1)     │ ◄──────► │  UID 0 (root)         │             │
│  │                       │  매핑    │                       │             │
│  │  UID 1001             │ ◄──────► │  UID 1                │             │
│  │  UID 1002             │ ◄──────► │  UID 2                │             │
│  │  ...                  │          │  ...                  │             │
│  │  UID 65535            │ ◄──────► │  UID 64535            │             │
│  │                       │          │                       │             │
│  └───────────────────────┘          └───────────────────────┘             │
│                                                                             │
│   /proc/<pid>/uid_map 내용:                                                 │
│   ┌─────────────────────────────────────────────────────────────────────┐  │
│   │  컨테이너UID   호스트UID    범위                                      │  │
│   │  0            1000        1        (컨테이너 root = 호스트 user1)    │  │
│   │  1            100000      65535    (subordinate UIDs)               │  │
│   └─────────────────────────────────────────────────────────────────────┘  │
│                                                                             │
│   장점:                                                                     │
│   • 컨테이너가 탈출해도 호스트에서는 일반 사용자 권한                        │
│   • 보안 강화: 권한 상승 공격 방어                                          │
│   • 멀티테넌트 환경에서 격리 강화                                           │
│                                                                             │
│   Subordinate UID/GID 설정 (/etc/subuid, /etc/subgid):                     │
│   ┌─────────────────────────────────────────────────────────────────────┐  │
│   │  user1:100000:65536                                                  │  │
│   │  ↑     ↑      ↑                                                      │  │
│   │  │     │      └── 할당 개수                                          │  │
│   │  │     └── 시작 UID                                                  │  │
│   │  └── 사용자명                                                         │  │
│   └─────────────────────────────────────────────────────────────────────┘  │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

> **💡 팁 (Tip)**: Kubernetes 1.25+에서는 User namespace를 지원합니다. `pod.spec.hostUsers: false`로 설정하면 Pod가 User namespace에서 실행됩니다.

### 3.7. 네임스페이스 조작 도구

```bash
# 현재 프로세스의 네임스페이스 확인
ls -la /proc/$$/ns/
# lrwxrwxrwx 1 root root 0 ... cgroup -> 'cgroup:[4026531835]'
# lrwxrwxrwx 1 root root 0 ... ipc -> 'ipc:[4026531839]'
# lrwxrwxrwx 1 root root 0 ... mnt -> 'mnt:[4026531840]'
# lrwxrwxrwx 1 root root 0 ... net -> 'net:[4026531992]'
# lrwxrwxrwx 1 root root 0 ... pid -> 'pid:[4026531836]'
# lrwxrwxrwx 1 root root 0 ... user -> 'user:[4026531837]'
# lrwxrwxrwx 1 root root 0 ... uts -> 'uts:[4026531838]'

# 시스템의 모든 네임스페이스 목록
lsns

# 특정 네임스페이스로 진입 (nsenter)
# 컨테이너의 네트워크 네임스페이스로 진입
nsenter -t <container-pid> -n ip addr

# 컨테이너의 모든 네임스페이스로 진입
nsenter -t <container-pid> -a bash

# unshare로 새 네임스페이스 생성
unshare --pid --fork --mount-proc bash  # 새 PID 네임스페이스
unshare --net bash                       # 새 Network 네임스페이스
unshare --uts bash                       # 새 UTS 네임스페이스 (호스트명)

# crictl로 컨테이너 PID 찾기 (Kubernetes 환경)
crictl inspect <container-id> | jq '.info.pid'
```

---

## 4. Control Groups (cgroups)

### 4.1. cgroups란?

cgroups(Control Groups)는 프로세스 그룹의 **리소스 사용량을 제한, 우선순위 지정, 계정, 격리**하는 Linux 커널 기능입니다.

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                          cgroups: 리소스 제어의 핵심                         │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   "cgroups = 프로세스 그룹에 대한 리소스 제한 및 계정"                        │
│                                                                             │
│   시스템 전체 리소스                                                         │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                                                                       │   │
│  │  CPU: 8 cores (800%)     Memory: 32GB     Disk I/O     Network       │   │
│  │                                                                       │   │
│  └───────────────────────────────┬───────────────────────────────────────┘   │
│                                  │                                           │
│                           cgroups hierarchy                                  │
│                                  │                                           │
│                    ┌─────────────┴─────────────┐                            │
│                    │         root (/)           │                            │
│                    │   모든 프로세스의 조상     │                            │
│                    └─────────────┬─────────────┘                            │
│                                  │                                           │
│         ┌────────────────────────┼────────────────────────┐                 │
│         │                        │                        │                 │
│         ▼                        ▼                        ▼                 │
│  ┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐         │
│  │  system.slice   │    │   user.slice    │    │ kubepods.slice  │         │
│  │  (시스템 서비스) │    │   (사용자 세션) │    │  (Kubernetes)   │         │
│  │                 │    │                 │    │                 │         │
│  │  CPU: 무제한    │    │  CPU: 무제한    │    │  CPU: 7 cores   │         │
│  │  Mem: 무제한    │    │  Mem: 무제한    │    │  Mem: 28GB      │         │
│  └────────┬────────┘    └─────────────────┘    └────────┬────────┘         │
│           │                                             │                   │
│           ▼                                             │                   │
│  ┌─────────────────┐              ┌─────────────────────┴───────────┐      │
│  │ containerd.service             │                                 │      │
│  │                 │              │                                 │      │
│  │  CPU: 무제한    │              ▼                                 ▼      │
│  │  Mem: 무제한    │    ┌─────────────────┐           ┌─────────────────┐  │
│  └─────────────────┘    │kubepods-burstable│          │kubepods-besteffort│ │
│                         │  (Burstable QoS) │          │ (BestEffort QoS)│  │
│                         │                 │           │                 │  │
│                         │  CPU: 공유      │           │  CPU: 공유      │  │
│                         │  Mem: 제한 있음 │           │  Mem: 제한 없음 │  │
│                         └────────┬────────┘           └─────────────────┘  │
│                                  │                                          │
│                                  ▼                                          │
│                   ┌───────────────────────────────┐                        │
│                   │  pod-<UID>.slice              │                        │
│                   │                               │                        │
│                   │  ┌─────────────────────────┐  │                        │
│                   │  │ container-<ID>.scope    │  │                        │
│                   │  │                         │  │                        │
│                   │  │ CPU: 500m (50%)         │  │                        │
│                   │  │ Memory: 256Mi           │  │                        │
│                   │  │                         │  │                        │
│                   │  │ [nginx 프로세스들]       │  │                        │
│                   │  └─────────────────────────┘  │                        │
│                   └───────────────────────────────┘                        │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 4.2. cgroups v1 vs v2

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                          cgroups v1 vs v2 비교                               │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   cgroups v1 (레거시)                  cgroups v2 (통합 계층)               │
│  ┌───────────────────────────┐        ┌───────────────────────────┐        │
│  │                           │        │                           │        │
│  │  /sys/fs/cgroup/          │        │  /sys/fs/cgroup/          │        │
│  │  ├── cpu/                 │        │  ├── cgroup.controllers   │        │
│  │  │   └── docker/          │        │  ├── cgroup.subtree_control│       │
│  │  │       └── <id>/        │        │  │                         │        │
│  │  │           ├── cpu.shares│       │  └── kubepods.slice/      │        │
│  │  │           └── tasks    │        │      ├── cpu.max          │        │
│  │  ├── memory/              │        │      ├── memory.max       │        │
│  │  │   └── docker/          │        │      ├── io.max           │        │
│  │  │       └── <id>/        │        │      ├── pids.max         │        │
│  │  │           ├── memory.limit│      │      └── cgroup.procs    │        │
│  │  │           └── tasks    │        │                           │        │
│  │  ├── cpuset/              │        │  단일 통합 계층 구조        │        │
│  │  ├── blkio/               │        │                           │        │
│  │  └── ... (컨트롤러별 분리) │        │                           │        │
│  │                           │        │                           │        │
│  │  각 컨트롤러가 독립 계층   │        │  모든 컨트롤러가 단일 계층  │        │
│  └───────────────────────────┘        └───────────────────────────┘        │
│                                                                             │
│  ┌───────────────────────────────────────────────────────────────────────┐ │
│  │ 특성              │ cgroups v1          │ cgroups v2                  │ │
│  ├───────────────────────────────────────────────────────────────────────┤ │
│  │ 계층 구조         │ 컨트롤러마다 독립    │ 단일 통합 계층              │ │
│  │ 스레드 지원       │ 제한적              │ 스레드 모드 지원            │ │
│  │ Pressure Stall   │ 미지원              │ PSI 지원 (cpu/memory/io)   │ │
│  │ 인터페이스       │ 분산, 복잡          │ 통합, 단순                  │ │
│  │ 권한 위임        │ 제한적              │ 개선된 위임 모델            │ │
│  │ Kubernetes       │ 지원 (레거시)       │ 권장 (1.25+)               │ │
│  │ RHEL 10          │ 미지원 (기본)       │ 기본값                      │ │
│  └───────────────────────────────────────────────────────────────────────┘ │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

> **📘 개념 (Concept)**: RHEL 10과 최신 커널은 cgroups v2를 기본으로 사용합니다. Kubernetes 1.25+와 containerd 1.7+는 cgroups v2를 완전히 지원합니다.

```bash
# cgroups 버전 확인
stat -fc %T /sys/fs/cgroup/
# cgroup2fs → v2
# tmpfs → v1 (하이브리드 또는 v1)

# v2에서 사용 가능한 컨트롤러 확인
cat /sys/fs/cgroup/cgroup.controllers
# cpuset cpu io memory hugetlb pids rdma misc

# 마운트 상태 확인
mount | grep cgroup
```

### 4.3. 주요 cgroups 컨트롤러

#### CPU 컨트롤러

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                           CPU 컨트롤러 (cgroups v2)                          │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   cpu.max: 대역폭 제한 (Hard Limit)                                         │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                                                                       │   │
│  │  형식: $MAX $PERIOD                                                   │   │
│  │  예: "50000 100000" = 100ms 주기 중 50ms 사용 = 50% CPU               │   │
│  │                                                                       │   │
│  │  ┌─────────────────────────────────────────────────────────────┐     │   │
│  │  │  Period = 100ms (100000µs)                                   │     │   │
│  │  │  ├──────────────────────────────────────────────────────────┤     │   │
│  │  │  │███████████████████████████│                              │     │   │
│  │  │  │      Max = 50ms           │     유휴 시간                 │     │   │
│  │  │  │      (CPU 사용 가능)       │     (스로틀링)               │     │   │
│  │  │  └──────────────────────────────────────────────────────────┘     │   │
│  │  │                                                                   │   │
│  │  │  "max 100000" = 무제한 (Kubernetes: limits 미설정)               │   │
│  │  └─────────────────────────────────────────────────────────────┘     │   │
│  │                                                                       │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│   cpu.weight: 상대적 가중치 (Soft Limit)                                    │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                                                                       │   │
│  │  범위: 1-10000 (기본값: 100)                                          │   │
│  │                                                                       │   │
│  │  예: cgroup A (weight=200), cgroup B (weight=100)                    │   │
│  │  → CPU 경합 시 A가 B보다 2배 많이 사용                                │   │
│  │                                                                       │   │
│  │  ┌────────────────────────────────────────────────────┐              │   │
│  │  │            전체 CPU (경합 발생 시)                  │              │   │
│  │  │  ┌────────────────────────┬────────────┐           │              │   │
│  │  │  │     cgroup A (2/3)     │ cgroup B   │           │              │   │
│  │  │  │     weight: 200        │  (1/3)     │           │              │   │
│  │  │  │                        │ weight:100 │           │              │   │
│  │  │  └────────────────────────┴────────────┘           │              │   │
│  │  └────────────────────────────────────────────────────┘              │   │
│  │                                                                       │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│   Kubernetes CPU 리소스 매핑:                                               │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │  resources:                                                          │   │
│  │    requests:                                                         │   │
│  │      cpu: "500m"   →  cpu.weight 계산에 사용                        │   │
│  │    limits:                                                           │   │
│  │      cpu: "1000m"  →  cpu.max = "100000 100000" (100%)              │   │
│  │                                                                       │   │
│  │  CPU 단위: 1 core = 1000m (millicores)                               │   │
│  │  500m = 0.5 core = cpu.max "50000 100000"                           │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

#### Memory 컨트롤러

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                         Memory 컨트롤러 (cgroups v2)                         │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   주요 파일:                                                                 │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                                                                       │   │
│  │  memory.max          하드 제한 (초과 시 OOM killer)                   │   │
│  │  memory.high         소프트 제한 (초과 시 스로틀링)                   │   │
│  │  memory.min          보장된 최소 메모리 (회수 불가)                   │   │
│  │  memory.low          회수 우선순위 낮음 (soft guarantee)             │   │
│  │  memory.current      현재 사용량                                     │   │
│  │  memory.swap.max     스왑 제한                                       │   │
│  │  memory.events       OOM, 스로틀링 이벤트 카운터                     │   │
│  │                                                                       │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│   메모리 제한 동작:                                                          │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                                                                       │   │
│  │  memory.max = 1GB                                                    │   │
│  │                                                                       │   │
│  │  ┌─────────────────────────────────────────────────────┐             │   │
│  │  │                     memory.max (1GB)                 │             │   │
│  │  │  ┌──────────────────────────────────────────────┐   │             │   │
│  │  │  │                                              │   │             │   │
│  │  │  │          memory.high (800MB)                 │   │             │   │
│  │  │  │  ┌──────────────────────────────────────┐   │   │             │   │
│  │  │  │  │                                      │   │   │             │   │
│  │  │  │  │       memory.current (사용중)         │   │   │             │   │
│  │  │  │  │                                      │   │   │             │   │
│  │  │  │  │   ███████████████████ (600MB)       │   │   │             │   │
│  │  │  │  │                                      │   │   │             │   │
│  │  │  │  └──────────────────────────────────────┘   │   │             │   │
│  │  │  │           ↑                                  │   │             │   │
│  │  │  │      정상 동작 영역                          │   │             │   │
│  │  │  └──────────────────────────────────────────────┘   │             │   │
│  │  │               ↑                                     │             │   │
│  │  │          스로틀링 영역 (high~max)                   │             │   │
│  │  └─────────────────────────────────────────────────────┘             │   │
│  │                   ↑                                                   │   │
│  │              OOM Kill 영역 (max 초과)                                 │   │
│  │                                                                       │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│   OOM Killer 동작:                                                          │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                                                                       │   │
│  │  1. 프로세스가 memory.max 초과 시도                                   │   │
│  │  2. 커널이 cgroup 내 프로세스 중 하나를 선택                          │   │
│  │  3. 선택 기준: oom_score (메모리 사용량, oom_score_adj 등)            │   │
│  │  4. SIGKILL 전송 → 프로세스 종료                                     │   │
│  │                                                                       │   │
│  │  Kubernetes QoS와 OOM 우선순위:                                       │   │
│  │  • BestEffort: oom_score_adj = 1000 (가장 먼저 종료)                 │   │
│  │  • Burstable:  oom_score_adj = 2~999 (중간)                         │   │
│  │  • Guaranteed: oom_score_adj = -997 (가장 나중에 종료)               │   │
│  │                                                                       │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

> **⚠️ 주의 (Warning)**: Kubernetes에서 `resources.limits.memory`를 설정하지 않으면 Pod가 무제한으로 메모리를 사용할 수 있어 노드 전체에 영향을 줄 수 있습니다. 항상 적절한 메모리 제한을 설정하세요.

### 4.4. cgroups 실습

```bash
# cgroup v2 디렉토리 구조 확인
ls /sys/fs/cgroup/
# cgroup.controllers  cgroup.max.depth  cgroup.procs  ...
# kubepods.slice/  system.slice/  user.slice/

# Kubernetes Pod의 cgroup 확인
# 1. Pod UID 확인
kubectl get pod <pod-name> -o jsonpath='{.metadata.uid}'

# 2. 컨테이너 ID 확인
crictl ps | grep <pod-name>

# 3. cgroup 경로 확인
cat /sys/fs/cgroup/kubepods.slice/kubepods-burstable.slice/\
kubepods-burstable-pod<UID>.slice/cri-containerd-<ID>.scope/memory.max

# 수동 cgroup 생성 (테스트용)
# 1. cgroup 디렉토리 생성
sudo mkdir /sys/fs/cgroup/test-group

# 2. CPU 제한 설정 (10%)
echo "10000 100000" | sudo tee /sys/fs/cgroup/test-group/cpu.max

# 3. 메모리 제한 설정 (100MB)
echo "104857600" | sudo tee /sys/fs/cgroup/test-group/memory.max

# 4. 현재 쉘을 cgroup에 추가
echo $$ | sudo tee /sys/fs/cgroup/test-group/cgroup.procs

# 5. 리소스 사용량 확인
cat /sys/fs/cgroup/test-group/cpu.stat
cat /sys/fs/cgroup/test-group/memory.current

# 6. 정리
echo $$ | sudo tee /sys/fs/cgroup/cgroup.procs  # 쉘을 루트로 이동
sudo rmdir /sys/fs/cgroup/test-group
```

---

## 5. 파일 시스템과 마운트

### 5.1. Linux 파일 시스템 계층 (FHS)

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                  Linux Filesystem Hierarchy Standard (FHS)                   │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   /                              루트 디렉토리                               │
│   ├── /bin → /usr/bin           필수 바이너리 (심볼릭 링크)                  │
│   ├── /boot                     부트로더, 커널 이미지                        │
│   │   ├── vmlinuz-*             압축된 커널                                 │
│   │   └── initramfs-*           초기 RAM 파일시스템                         │
│   ├── /dev                      디바이스 파일 (udev 관리)                    │
│   │   ├── /dev/null             널 디바이스                                 │
│   │   ├── /dev/zero             제로 디바이스                               │
│   │   ├── /dev/sda              블록 디바이스 (디스크)                       │
│   │   └── /dev/pts/             가상 터미널                                 │
│   ├── /etc                      시스템 설정 파일                            │
│   │   ├── /etc/hosts            호스트명 매핑                               │
│   │   ├── /etc/resolv.conf      DNS 설정                                   │
│   │   ├── /etc/containerd/      containerd 설정                            │
│   │   └── /etc/kubernetes/      Kubernetes 설정                            │
│   ├── /home                     사용자 홈 디렉토리                          │
│   ├── /lib → /usr/lib           공유 라이브러리 (심볼릭 링크)                │
│   ├── /lib64 → /usr/lib64       64비트 라이브러리                           │
│   ├── /mnt                      임시 마운트 포인트                          │
│   ├── /opt                      서드파티 소프트웨어                         │
│   │   └── /opt/cni/bin/         CNI 플러그인 바이너리                       │
│   ├── /proc                     프로세스 정보 (procfs, 가상)                │
│   │   ├── /proc/<PID>/          프로세스별 정보                             │
│   │   │   ├── /proc/<PID>/ns/   네임스페이스 핸들                           │
│   │   │   ├── /proc/<PID>/cgroup cgroup 소속 정보                          │
│   │   │   └── /proc/<PID>/root  루트 파일시스템                             │
│   │   ├── /proc/cpuinfo         CPU 정보                                   │
│   │   ├── /proc/meminfo         메모리 정보                                │
│   │   └── /proc/sys/            커널 파라미터 (sysctl)                      │
│   ├── /run                      런타임 데이터 (tmpfs)                       │
│   │   ├── /run/containerd/      containerd 소켓, 상태                      │
│   │   └── /run/flannel/         Flannel 상태 (사용 시)                     │
│   ├── /sys                      커널/디바이스 정보 (sysfs, 가상)            │
│   │   ├── /sys/fs/cgroup/       cgroups v2 계층                           │
│   │   ├── /sys/class/net/       네트워크 인터페이스                         │
│   │   └── /sys/kernel/          커널 정보                                  │
│   ├── /tmp                      임시 파일 (재부팅 시 삭제)                   │
│   ├── /usr                      사용자 프로그램                             │
│   │   ├── /usr/bin/             사용자 바이너리                             │
│   │   │   ├── kubectl           Kubernetes CLI                            │
│   │   │   ├── kubeadm           클러스터 부트스트랩                         │
│   │   │   └── crictl            컨테이너 런타임 CLI                         │
│   │   └── /usr/local/bin/       로컬 바이너리                               │
│   │       ├── helm              Helm CLI                                   │
│   │       └── cilium            Cilium CLI                                 │
│   └── /var                      가변 데이터                                 │
│       ├── /var/lib/             서비스 상태 데이터                          │
│       │   ├── containerd/       컨테이너 데이터, 이미지                     │
│       │   ├── kubelet/          kubelet 데이터                             │
│       │   └── etcd/             etcd 데이터                                │
│       └── /var/log/             로그 파일                                  │
│           ├── /var/log/pods/    Pod 로그                                   │
│           └── /var/log/containers/ 컨테이너 로그 (심볼릭 링크)              │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 5.2. 오버레이 파일 시스템 (OverlayFS)

컨테이너 이미지는 오버레이 파일 시스템을 사용하여 레이어를 효율적으로 관리합니다.

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    OverlayFS: 컨테이너 이미지의 핵심                         │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   OverlayFS = Union Mount (여러 디렉토리를 하나로 보이게)                    │
│                                                                             │
│   ┌─────────────────────────────────────────────────────────────────────┐  │
│   │                      Merged (통합 뷰)                                │  │
│   │                   컨테이너가 실제로 보는 파일시스템                    │  │
│   │  ┌─────────────────────────────────────────────────────────────┐    │  │
│   │  │  /bin/bash    ← Lower에서 온 파일                            │    │  │
│   │  │  /etc/nginx/  ← Lower에서 온 디렉토리                        │    │  │
│   │  │  /app/config  ← Upper에서 온 새 파일 (컨테이너가 생성)         │    │  │
│   │  │  /var/log/    ← Lower + Upper 병합                          │    │  │
│   │  └─────────────────────────────────────────────────────────────┘    │  │
│   └─────────────────────────────────────────────────────────────────────┘  │
│                                    ▲                                       │
│                                    │ overlay mount                         │
│                                    │                                       │
│   ┌───────────────────────┐  ┌─────┴─────┐  ┌────────────────────────────┐│
│   │   Upper (읽기/쓰기)    │  │   Work    │  │    Lower (읽기 전용)       ││
│   │   컨테이너 레이어       │  │  (내부용) │  │    이미지 레이어들         ││
│   │                       │  │           │  │                            ││
│   │  /var/lib/containerd/ │  │           │  │  layer3/ (app code)       ││
│   │  .../upper/           │  │           │  │  layer2/ (dependencies)   ││
│   │                       │  │           │  │  layer1/ (base OS)        ││
│   │  새로 생성된 파일:     │  │           │  │                            ││
│   │  • /app/config        │  │           │  │  불변 (Immutable)          ││
│   │  • /var/log/app.log   │  │           │  │  여러 컨테이너가 공유 가능  ││
│   │                       │  │           │  │                            ││
│   └───────────────────────┘  └───────────┘  └────────────────────────────┘│
│                                                                             │
│   Copy-on-Write (CoW) 동작:                                                 │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                                                                       │   │
│  │  1. 읽기: Lower 레이어에서 직접 읽음 (복사 없음)                       │   │
│  │                                                                       │   │
│  │  2. 수정: Lower의 파일 수정 시                                        │   │
│  │     a. Lower의 파일을 Upper로 복사                                    │   │
│  │     b. Upper의 복사본을 수정                                          │   │
│  │     c. Merged에서는 Upper 버전이 보임 (Lower 가림)                    │   │
│  │                                                                       │   │
│  │  3. 삭제: "whiteout" 파일 생성                                        │   │
│  │     Lower의 /etc/config 삭제 시                                       │   │
│  │     → Upper에 .wh.config 파일 생성                                   │   │
│  │     → Merged에서 /etc/config가 사라짐                                 │   │
│  │                                                                       │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│   마운트 명령 예시:                                                          │
│   mount -t overlay overlay -o \                                             │
│     lowerdir=/layer1:/layer2:/layer3,\                                      │
│     upperdir=/upper,\                                                       │
│     workdir=/work \                                                         │
│     /merged                                                                 │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

> **💡 팁 (Tip)**: 컨테이너 이미지의 레이어 구조를 이해하면 이미지 크기 최적화가 가능합니다. Dockerfile에서 자주 변경되는 레이어를 아래쪽에, 변경이 적은 레이어(베이스 이미지, 의존성)를 위쪽에 배치하면 캐시 효율이 높아집니다.

---

## 6. 시스템 콜

### 6.1. 시스템 콜의 역할

시스템 콜(syscall)은 사용자 공간 프로그램이 커널 기능을 요청하는 **유일한 공식 인터페이스**입니다.

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                          시스템 콜 동작 과정                                  │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   User Space (Ring 3)                                                       │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                                                                       │   │
│  │  ① Application: fd = open("/etc/hosts", O_RDONLY)                   │   │
│  │         │                                                            │   │
│  │         ▼                                                            │   │
│  │  ② C Library (glibc): open() wrapper function                       │   │
│  │         │                                                            │   │
│  │         │ 시스템 콜 번호와 인자 설정                                  │   │
│  │         │ - rax = 2 (SYS_open)                                       │   │
│  │         │ - rdi = "/etc/hosts" 포인터                                │   │
│  │         │ - rsi = O_RDONLY (0)                                       │   │
│  │         ▼                                                            │   │
│  │  ③ syscall instruction (x86_64)                                     │   │
│  │         │                                                            │   │
│  └─────────┼───────────────────────────────────────────────────────────┘   │
│            │                                                               │
│            │ ④ Mode Switch: User → Kernel                                │
│            │    (CPU 권한 레벨 변경, 레지스터 저장)                        │
│            │                                                               │
│            ▼                                                               │
│   Kernel Space (Ring 0)                                                    │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                                                                       │   │
│  │  ⑤ System Call Handler (entry_SYSCALL_64)                           │   │
│  │         │                                                            │   │
│  │         │ 시스템 콜 테이블에서 핸들러 조회                            │   │
│  │         │ syscall_table[rax] = sys_open                              │   │
│  │         ▼                                                            │   │
│  │  ⑥ sys_open() → VFS → ext4/overlayfs → ...                         │   │
│  │         │                                                            │   │
│  │         │ 파일 열기 수행                                              │   │
│  │         │ - 권한 검사                                                 │   │
│  │         │ - 파일 디스크립터 할당                                      │   │
│  │         │ - 파일 객체 생성                                            │   │
│  │         │                                                            │   │
│  │         │ 결과: fd = 3                                               │   │
│  │         ▼                                                            │   │
│  │  ⑦ 결과를 rax에 저장                                                │   │
│  │         │                                                            │   │
│  └─────────┼───────────────────────────────────────────────────────────┘   │
│            │                                                               │
│            │ ⑧ Mode Switch: Kernel → User                                │
│            │    (sysret instruction)                                      │
│            │                                                               │
│            ▼                                                               │
│   User Space                                                               │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                                                                       │   │
│  │  ⑨ Application: fd = 3 (파일 디스크립터 반환)                        │   │
│  │                                                                       │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│   소요 시간: 약 50-100 나노초 (컨텍스트 스위칭 포함)                         │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 6.2. 컨테이너 관련 주요 시스템 콜

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    컨테이너 런타임이 사용하는 시스템 콜                       │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ 카테고리        │ 시스템 콜              │ 용도                      │   │
│  ├─────────────────────────────────────────────────────────────────────┤   │
│  │ 네임스페이스    │ clone(CLONE_NEW*)      │ 새 네임스페이스 생성      │   │
│  │                │ unshare()              │ 현재 프로세스 네임스페이스 분리│ │
│  │                │ setns()                │ 기존 네임스페이스 진입     │   │
│  ├─────────────────────────────────────────────────────────────────────┤   │
│  │ cgroups        │ mkdir/rmdir            │ cgroup 생성/삭제          │   │
│  │                │ write (cgroup files)   │ 리소스 제한 설정          │   │
│  │                │ open/read              │ 상태 모니터링             │   │
│  ├─────────────────────────────────────────────────────────────────────┤   │
│  │ 프로세스       │ clone/fork             │ 프로세스 생성             │   │
│  │                │ execve                 │ 프로그램 실행             │   │
│  │                │ wait4                  │ 자식 프로세스 대기        │   │
│  │                │ kill                   │ 시그널 전송               │   │
│  ├─────────────────────────────────────────────────────────────────────┤   │
│  │ 파일시스템     │ pivot_root             │ 루트 파일시스템 변경      │   │
│  │                │ mount                  │ 파일시스템 마운트         │   │
│  │                │ umount2                │ 파일시스템 언마운트       │   │
│  │                │ chroot                 │ 루트 디렉토리 변경        │   │
│  ├─────────────────────────────────────────────────────────────────────┤   │
│  │ 보안           │ prctl(PR_SET_SECCOMP)  │ seccomp 필터 설정        │   │
│  │                │ capset                 │ 캐퍼빌리티 설정           │   │
│  │                │ setuid/setgid          │ 사용자/그룹 ID 설정       │   │
│  ├─────────────────────────────────────────────────────────────────────┤   │
│  │ 네트워크       │ socket                 │ 소켓 생성                │   │
│  │                │ bind/listen/accept     │ 서버 소켓 설정           │   │
│  │                │ connect                │ 연결                     │   │
│  │                │ sendto/recvfrom        │ 데이터 전송              │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  runc가 컨테이너 생성 시 호출하는 시스템 콜 순서 (간략화):                    │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │  1. clone(CLONE_NEWPID | CLONE_NEWNS | CLONE_NEWNET | ...)         │   │
│  │  2. mount("/", "/", NULL, MS_PRIVATE | MS_REC, NULL)               │   │
│  │  3. mount("overlay", "/merged", "overlay", ...)                    │   │
│  │  4. pivot_root("/merged", "/merged/.pivot_root")                   │   │
│  │  5. umount2("/.pivot_root", MNT_DETACH)                            │   │
│  │  6. mount("proc", "/proc", "proc", ...)                            │   │
│  │  7. mount("sysfs", "/sys", "sysfs", ...)                           │   │
│  │  8. prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, ...)                │   │
│  │  9. setuid(0), setgid(0) (User namespace 내에서)                   │   │
│  │  10. execve("/entrypoint.sh", argv, envp)                          │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 6.3. strace를 이용한 시스템 콜 추적

```bash
# 기본 사용법: 프로세스의 모든 시스템 콜 추적
strace ls /

# 특정 시스템 콜만 추적
strace -e openat,read,write cat /etc/hosts

# 포크된 자식 프로세스도 추적
strace -f docker run --rm alpine echo hello

# 시스템 콜 통계
strace -c ls /

# 실행 중인 프로세스에 연결
strace -p <PID>

# 컨테이너 프로세스 추적 (containerd 환경)
# 1. 컨테이너 PID 찾기
crictl inspect <container-id> | jq '.info.pid'

# 2. strace 연결
sudo strace -f -p <container-pid>

# 출력 예시:
# openat(AT_FDCWD, "/etc/hosts", O_RDONLY) = 3
# read(3, "127.0.0.1 localhost\n...", 4096) = 234
# close(3) = 0
```

> **🔍 심화 학습 (Deep Dive)**: seccomp(Secure Computing Mode)는 컨테이너가 호출할 수 있는 시스템 콜을 제한합니다. Kubernetes의 기본 seccomp 프로파일은 위험한 시스템 콜(예: `reboot`, `kexec_load`)을 차단합니다.

---

## 이 장의 요약

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                            핵심 요약                                        │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │  개념           │  역할                    │  컨테이너/K8s 적용      │   │
│  ├─────────────────────────────────────────────────────────────────────┤   │
│  │  Linux 커널     │  하드웨어-소프트웨어 중재  │  컨테이너 실행 기반     │   │
│  │  프로세스       │  실행 단위               │  컨테이너 = 격리된 프로세스│  │
│  │  네임스페이스   │  리소스 뷰 격리          │  7가지 격리 (PID,Net,..) │   │
│  │  cgroups       │  리소스 제한/계정         │  Pod resources 적용     │   │
│  │  OverlayFS     │  레이어드 파일시스템       │  컨테이너 이미지        │   │
│  │  시스템 콜      │  커널 기능 인터페이스     │  컨테이너 런타임 동작   │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  컨테이너 = 네임스페이스 + cgroups + 루트 파일시스템 변경                    │
│                                                                             │
│  "컨테이너는 특별한 프로세스일 뿐이다"                                       │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## 실습 과제

### 과제 1: 네임스페이스 직접 생성하기
```bash
# PID + Mount + UTS 네임스페이스를 가진 격리된 환경 만들기
# 힌트: unshare --pid --fork --mount-proc --uts bash
```

### 과제 2: cgroups로 리소스 제한하기
```bash
# CPU 10%, 메모리 50MB 제한된 cgroup 만들고 stress 테스트
# 힌트: /sys/fs/cgroup/<name>/cpu.max, memory.max
```

### 과제 3: 컨테이너 프로세스 분석
```bash
# 실행 중인 컨테이너의 네임스페이스와 cgroup 정보 확인
# 힌트: /proc/<pid>/ns/, /proc/<pid>/cgroup
```

---

## 학습 점검

### Q1. 컨테이너가 VM보다 가벼운 이유는?
<details>
<summary>정답 보기</summary>

컨테이너는 호스트 커널을 공유하고, 네임스페이스와 cgroups로 격리만 수행합니다. 반면 VM은 전체 OS 커널을 포함한 게스트 OS를 실행해야 하므로 오버헤드가 큽니다.
</details>

### Q2. PID 네임스페이스에서 컨테이너 내 PID 1이 중요한 이유는?
<details>
<summary>정답 보기</summary>

PID 1 프로세스는 해당 네임스페이스의 init 프로세스 역할을 합니다. 이 프로세스가 종료되면 네임스페이스 전체가 종료됩니다. 또한 고아 프로세스의 부모가 되어 reaping 책임이 있습니다.
</details>

### Q3. cgroups v2에서 cpu.max "50000 100000"의 의미는?
<details>
<summary>정답 보기</summary>

100,000µs(100ms) 주기 동안 최대 50,000µs(50ms)의 CPU 시간을 사용할 수 있습니다. 즉 CPU의 50%를 제한합니다.
</details>

### Q4. OverlayFS에서 Copy-on-Write가 발생하는 시점은?
<details>
<summary>정답 보기</summary>

Lower(읽기 전용) 레이어의 파일을 **수정**하려고 할 때 발생합니다. 읽기만 할 때는 복사가 일어나지 않고, 수정 시에만 Upper 레이어로 복사 후 수정합니다.
</details>

---

## 다음 단계

- [02-container-fundamentals.md](02-container-fundamentals.md) - 컨테이너 기초: OCI 표준, containerd, 이미지 구조

---

## 참고 자료

### 공식 문서
- [Linux Kernel Documentation](https://www.kernel.org/doc/html/latest/)
- [Namespaces man page](https://man7.org/linux/man-pages/man7/namespaces.7.html)
- [cgroups v2 Documentation](https://www.kernel.org/doc/html/latest/admin-guide/cgroup-v2.html)
- [OverlayFS Documentation](https://www.kernel.org/doc/html/latest/filesystems/overlayfs.html)

### 서적
- "Linux Kernel Development" by Robert Love
- "Understanding the Linux Kernel" by Daniel P. Bovet
- "Container Security" by Liz Rice

### 도구
- [unshare(1)](https://man7.org/linux/man-pages/man1/unshare.1.html) - 네임스페이스 생성
- [nsenter(1)](https://man7.org/linux/man-pages/man1/nsenter.1.html) - 네임스페이스 진입
- [lsns(1)](https://man7.org/linux/man-pages/man1/lsns.1.html) - 네임스페이스 목록
- [strace(1)](https://man7.org/linux/man-pages/man1/strace.1.html) - 시스템 콜 추적
