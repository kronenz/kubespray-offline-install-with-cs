# 컨테이너 기초

> *"컨테이너는 기술적 혁신이 아니라 패키징 혁신이다. 그것은 소프트웨어를 어디서든 동일하게 실행할 수 있게 만든 것이다."*
> — Solomon Hykes, Docker 창시자

소프트웨어 개발의 역사에서 "내 컴퓨터에서는 되는데..."라는 말만큼 개발자와 운영팀 사이에 갈등을 일으킨 문장은 없을 것입니다. 컨테이너 기술은 바로 이 문제를 해결하기 위해 탄생했습니다. 이 장에서는 컨테이너가 어떻게 작동하는지, 그 내부 메커니즘을 깊이 있게 살펴봅니다.

컨테이너는 마법이 아닙니다. 이전 장에서 배운 Linux 네임스페이스와 cgroups를 영리하게 조합한 것입니다. 여기에 표준화된 이미지 형식과 런타임 인터페이스가 더해져, 오늘날 우리가 사용하는 컨테이너 생태계가 완성되었습니다.

---

## 이 장에서 다루는 내용

이 장을 읽고 나면 다음을 이해할 수 있습니다:

- **컨테이너의 본질**: VM과 컨테이너의 근본적인 차이점
- **OCI 표준**: 컨테이너 생태계를 가능하게 한 세 가지 핵심 표준
- **컨테이너 런타임 계층**: High-level과 Low-level 런타임의 역할 분담
- **CRI (Container Runtime Interface)**: Kubernetes가 런타임과 통신하는 방법
- **이미지 구조와 레이어**: Copy-on-Write와 overlayfs의 동작 원리
- **containerd 아키텍처**: Kubernetes에서 가장 많이 사용되는 런타임의 내부 구조
- **이미지 레지스트리**: 이미지 저장소와 프록시 레지스트리의 동작 방식

> **📘 개념 (Concept)**: 컨테이너 기술을 깊이 이해하면 Kubernetes 클러스터의 문제를 근본적으로 해결할 수 있습니다. "Pod가 시작되지 않는다"는 증상 뒤에는 항상 이미지 pull 실패, 런타임 오류, 또는 리소스 부족 같은 구체적인 원인이 있습니다.

---

## 1. 컨테이너란?

### 1.1. 컨테이너의 정의

컨테이너는 **애플리케이션과 그 의존성을 패키징하여 격리된 환경에서 실행**하는 기술입니다. 하지만 이 정의만으로는 컨테이너의 혁신성을 이해하기 어렵습니다. 컨테이너가 해결한 진짜 문제는 무엇일까요?

전통적인 소프트웨어 배포 방식을 생각해봅시다. 애플리케이션을 서버에 배포하려면:

1. 운영체제에 필요한 라이브러리를 설치합니다
2. 특정 버전의 런타임(Java, Python, Node.js 등)을 설치합니다
3. 환경 변수와 설정 파일을 구성합니다
4. 애플리케이션 바이너리를 복사합니다
5. 모든 것이 올바르게 작동하기를 기도합니다 🙏

이 과정에서 "개발 서버에서는 되는데 프로덕션에서는 안 된다"는 문제가 끊임없이 발생했습니다. 라이브러리 버전 충돌, 환경 변수 누락, 설정 파일 차이... 원인은 다양했지만 결과는 항상 같았습니다: 야근.

> **💡 팁 (Tip)**: 컨테이너는 "실행 환경 자체를 패키징"함으로써 이 문제를 해결합니다. 애플리케이션이 필요로 하는 모든 것(라이브러리, 런타임, 설정)이 이미지 안에 포함되어 있어, 어디서든 동일하게 실행됩니다.

\`\`\`
┌─────────────────────────────────────────────────────────────────────────────┐
│                     가상머신 vs 컨테이너                                     │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   가상머신 (VM)                          컨테이너                            │
│  ┌─────────────────────────┐          ┌─────────────────────────┐          │
│  │  App A  │  App B  │App C│          │  App A  │  App B  │App C│          │
│  ├─────────┼─────────┼─────┤          ├─────────┼─────────┼─────┤          │
│  │  Bins   │  Bins   │Bins │          │  Bins   │  Bins   │Bins │          │
│  │  Libs   │  Libs   │Libs │          │  Libs   │  Libs   │Libs │          │
│  ├─────────┼─────────┼─────┤          └─────────┴─────────┴─────┘          │
│  │ Guest OS│Guest OS │Guest│               Container Runtime               │
│  │ (Linux) │(Windows)│ OS  │          ┌─────────────────────────┐          │
│  └─────────┴─────────┴─────┘          │    (containerd/CRI-O)   │          │
│  ┌─────────────────────────┐          └─────────────────────────┘          │
│  │      Hypervisor         │          ┌─────────────────────────┐          │
│  │   (KVM, VMware, Hyper-V)│          │      Host OS (Linux)    │          │
│  └─────────────────────────┘          │  Kernel + Namespaces    │          │
│  ┌─────────────────────────┐          │  + cgroups              │          │
│  │      Host OS            │          └─────────────────────────┘          │
│  └─────────────────────────┘          ┌─────────────────────────┐          │
│  ┌─────────────────────────┐          │      Hardware           │          │
│  │      Hardware           │          └─────────────────────────┘          │
│  └─────────────────────────┘                                               │
│                                                                             │
│   • 각 VM에 전체 OS 필요              • 호스트 커널 공유                     │
│   • GB 단위 이미지                    • MB 단위 이미지                       │
│   • 분 단위 시작 시간                 • 초 단위 시작 시간                    │
│   • 높은 격리 (하드웨어 수준)          • 낮은 격리 (프로세스 수준)            │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
\`\`\`

### 1.2. 컨테이너 = 네임스페이스 + cgroups + 파일시스템

컨테이너의 핵심을 한 문장으로 요약하면 이렇습니다: **"격리된 프로세스 + 제한된 리소스 + 독립된 파일시스템"**

이전 장에서 배운 Linux 기능들이 어떻게 조합되는지 살펴봅시다:

\`\`\`
┌─────────────────────────────────────────────────────────────────────────────┐
│                        컨테이너의 구성 요소                                  │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   Container                                                                 │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                                                                       │   │
│  │   1. 네임스페이스 (Namespaces) - 격리                                 │   │
│  │   ┌─────────┬─────────┬─────────┬─────────┬─────────┬─────────┐      │   │
│  │   │   PID   │   NET   │   MNT   │   UTS   │   IPC   │   USER  │      │   │
│  │   │프로세스 │네트워크 │마운트   │호스트명 │IPC     │사용자ID │      │   │
│  │   │ 격리    │ 격리    │ 격리    │ 격리    │ 격리    │ 격리    │      │   │
│  │   └─────────┴─────────┴─────────┴─────────┴─────────┴─────────┘      │   │
│  │                                                                       │   │
│  │   2. cgroups - 리소스 제한                                            │   │
│  │   ┌─────────┬─────────┬─────────┬─────────┐                          │   │
│  │   │   CPU   │ Memory  │   I/O   │  PIDs   │                          │   │
│  │   │ 500m    │ 256Mi   │  제한   │   100   │                          │   │
│  │   └─────────┴─────────┴─────────┴─────────┘                          │   │
│  │                                                                       │   │
│  │   3. 루트 파일시스템 (Root Filesystem)                                │   │
│  │   ┌─────────────────────────────────────────────────────────────┐    │   │
│  │   │  /                                                           │    │   │
│  │   │  ├── /bin     (busybox, sh)                                 │    │   │
│  │   │  ├── /etc     (설정 파일)                                    │    │   │
│  │   │  ├── /lib     (라이브러리)                                   │    │   │
│  │   │  └── /app     (애플리케이션)                                 │    │   │
│  │   └─────────────────────────────────────────────────────────────┘    │   │
│  │                                                                       │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│   컨테이너 = 격리된 프로세스 + 제한된 리소스 + 독립된 파일시스템             │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
\`\`\`

> **🔍 심화 학습 (Deep Dive)**: 컨테이너가 "가벼운 이유"는 커널을 공유하기 때문입니다. VM은 각각 별도의 커널을 실행하지만, 컨테이너는 호스트 커널 위에서 네임스페이스로 격리될 뿐입니다. 이것이 컨테이너가 초 단위로 시작되고, MB 단위의 이미지 크기를 가질 수 있는 이유입니다.

### 1.3. 컨테이너의 역사와 발전

컨테이너 개념은 Docker가 처음이 아닙니다. 오랜 역사를 가지고 있습니다:

| 연도 | 기술 | 설명 |
|------|------|------|
| 1979 | **chroot** | Unix V7에서 루트 디렉토리 변경 기능 도입 |
| 2000 | **FreeBSD Jails** | 프로세스 격리 + 네트워크 격리 |
| 2001 | **Linux VServer** | Linux에서 OS 레벨 가상화 시도 |
| 2004 | **Solaris Zones** | Solaris에서 컨테이너 개념 구현 |
| 2006 | **cgroups** | Google에서 개발, Linux 커널에 병합 |
| 2008 | **LXC (Linux Containers)** | Linux 네임스페이스 + cgroups 조합 |
| 2013 | **Docker** | 사용하기 쉬운 컨테이너 도구 + 이미지 형식 |
| 2015 | **OCI 설립** | 컨테이너 표준화 시작 |
| 2016 | **containerd** | Docker에서 분리, CNCF에 기부 |
| 2017 | **CRI-O** | Kubernetes 전용 경량 런타임 |

> **📘 개념 (Concept)**: Docker의 진정한 혁신은 기술 자체가 아니라 **사용성**과 **이미지 형식**입니다. 복잡한 네임스페이스와 cgroups 설정을 \`docker run\` 한 줄로 추상화하고, 이미지를 쉽게 공유할 수 있게 만든 것이 핵심입니다.

### 1.4. 컨테이너의 장점과 트레이드오프

| 장점 | 설명 | 주의사항 |
|------|------|----------|
| **이식성** | "내 컴퓨터에서 되는데..." 문제 해결 | 커널 버전 차이는 여전히 영향 |
| **경량성** | VM 대비 빠른 시작, 적은 리소스 | 커널 공유로 인한 격리 수준 낮음 |
| **일관성** | 개발/테스트/프로덕션 환경 동일 | 이미지 빌드 과정의 재현성 필요 |
| **격리** | 애플리케이션 간 충돌 방지 | 커널 취약점은 모든 컨테이너에 영향 |
| **버전 관리** | 이미지 태그로 버전 관리 | 이미지 크기 관리 필요 |
| **확장성** | 수평 확장 용이 (Kubernetes) | 상태 관리(stateful) 애플리케이션은 복잡 |

> **⚠️ 주의 (Warning)**: 컨테이너는 VM 수준의 격리를 제공하지 않습니다. 커널 취약점이 발견되면 모든 컨테이너가 영향을 받을 수 있습니다. 보안이 중요한 환경에서는 gVisor나 Kata Containers 같은 강화된 런타임을 고려하세요.

### 섹션 요약

- 컨테이너는 **네임스페이스(격리) + cgroups(제한) + 파일시스템(패키징)**의 조합
- VM과 달리 **호스트 커널을 공유**하여 가볍고 빠름
- Docker의 혁신은 기술 자체보다 **사용성과 이미지 형식의 표준화**
- 컨테이너는 이식성을 제공하지만, **커널 의존성**은 여전히 존재

---

## 2. OCI 표준

### 2.1. OCI란 무엇인가?

OCI(Open Container Initiative)는 2015년 Docker, CoreOS, Google, Microsoft 등이 함께 설립한 단체로, **컨테이너 형식과 런타임의 산업 표준**을 정의합니다.

왜 표준이 필요했을까요? Docker가 컨테이너 시장을 독점하던 2015년, 업계는 우려를 가지기 시작했습니다. 하나의 회사가 사실상의 표준을 통제하는 것은 생태계 발전에 좋지 않았기 때문입니다. CoreOS는 Docker의 대안으로 rkt(로켓)을 개발했고, 이로 인해 컨테이너 생태계가 분열될 위기에 처했습니다.

OCI는 이 문제를 해결하기 위해 탄생했습니다. Docker가 자신의 이미지 형식과 런타임(runc)을 기부하면서, 업계는 공통 표준에 합의할 수 있었습니다.

> **📘 개념 (Concept)**: OCI 표준 덕분에 Docker로 빌드한 이미지를 Podman으로 실행하고, containerd로 관리할 수 있습니다. 이것이 오늘날 다양한 컨테이너 도구들이 상호 운용될 수 있는 이유입니다.

\`\`\`
┌─────────────────────────────────────────────────────────────────────────────┐
│                           OCI 표준 3가지                                     │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   OCI (Open Container Initiative)                                          │
│                                                                             │
│   1. OCI Image Specification (이미지 표준)                                  │
│   ┌─────────────────────────────────────────────────────────────────────┐  │
│   │  • 이미지 형식 정의 (레이어, 매니페스트, 설정)                        │  │
│   │  • 레지스트리 간 이미지 호환성 보장                                   │  │
│   │  • Docker, Podman, containerd 등에서 동일 이미지 사용                │  │
│   │  • 참조: https://github.com/opencontainers/image-spec               │  │
│   └─────────────────────────────────────────────────────────────────────┘  │
│                                                                             │
│   2. OCI Runtime Specification (런타임 표준)                                │
│   ┌─────────────────────────────────────────────────────────────────────┐  │
│   │  • 컨테이너 런타임 동작 정의                                         │  │
│   │  • config.json: 컨테이너 설정 (네임스페이스, cgroups, 마운트 등)     │  │
│   │  • rootfs/: 루트 파일시스템                                          │  │
│   │  • 생명주기: create → start → (running) → stop → delete             │  │
│   │  • 참조: https://github.com/opencontainers/runtime-spec             │  │
│   └─────────────────────────────────────────────────────────────────────┘  │
│                                                                             │
│   3. OCI Distribution Specification (배포 표준)                             │
│   ┌─────────────────────────────────────────────────────────────────────┐  │
│   │  • 레지스트리 API 표준 (HTTP 기반)                                   │  │
│   │  • 이미지 push/pull 프로토콜                                         │  │
│   │  • Docker Hub, Harbor, Quay, GHCR 등 호환                           │  │
│   │  • 참조: https://github.com/opencontainers/distribution-spec        │  │
│   └─────────────────────────────────────────────────────────────────────┘  │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
\`\`\`

### 2.2. OCI Image Specification 상세

OCI 이미지는 세 가지 핵심 구성 요소로 이루어집니다:

\`\`\`
┌─────────────────────────────────────────────────────────────────────────────┐
│                       OCI 이미지 구성 요소                                    │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   Image Reference: docker.io/library/nginx:1.25-alpine                     │
│                                                                             │
│   ┌─────────────────────────────────────────────────────────────────────┐  │
│   │  1. Image Index (선택적, 멀티 아키텍처용)                            │  │
│   │  {                                                                   │  │
│   │    "schemaVersion": 2,                                              │  │
│   │    "manifests": [                                                    │  │
│   │      { "platform": {"os":"linux","architecture":"amd64"}, ...},     │  │
│   │      { "platform": {"os":"linux","architecture":"arm64"}, ...}      │  │
│   │    ]                                                                 │  │
│   │  }                                                                   │  │
│   └─────────────────────────────────────────────────────────────────────┘  │
│                              │                                             │
│                              ▼                                             │
│   ┌─────────────────────────────────────────────────────────────────────┐  │
│   │  2. Image Manifest (아키텍처별 매니페스트)                           │  │
│   │  {                                                                   │  │
│   │    "schemaVersion": 2,                                              │  │
│   │    "mediaType": "application/vnd.oci.image.manifest.v1+json",       │  │
│   │    "config": {                                                       │  │
│   │      "mediaType": "application/vnd.oci.image.config.v1+json",       │  │
│   │      "digest": "sha256:abc123...",                                  │  │
│   │      "size": 7023                                                    │  │
│   │    },                                                                │  │
│   │    "layers": [                                                       │  │
│   │      {"mediaType":"...","digest":"sha256:layer1...","size":3408129},│  │
│   │      {"mediaType":"...","digest":"sha256:layer2...","size":1234567} │  │
│   │    ]                                                                 │  │
│   │  }                                                                   │  │
│   └─────────────────────────────────────────────────────────────────────┘  │
│                    │                              │                        │
│                    ▼                              ▼                        │
│   ┌────────────────────────────┐  ┌─────────────────────────────────────┐ │
│   │  3. Image Config            │  │  4. Layers (레이어들)               │ │
│   │  {                          │  │                                      │ │
│   │   "architecture": "amd64",  │  │  ┌─────────────────────────────┐   │ │
│   │   "os": "linux",            │  │  │ Layer N: app 변경 사항      │   │ │
│   │   "config": {               │  │  ├─────────────────────────────┤   │ │
│   │     "Env": [                │  │  │ Layer 2: 패키지 설치        │   │ │
│   │       "PATH=/usr/local/bin" │  │  ├─────────────────────────────┤   │ │
│   │     ],                      │  │  │ Layer 1: base image         │   │ │
│   │     "Cmd": ["nginx", "-g".. │  │  └─────────────────────────────┘   │ │
│   │   },                        │  │                                      │ │
│   │   "rootfs": {               │  │  각 레이어는 tar.gz 아카이브       │ │
│   │     "type": "layers",       │  │  (Content-Addressable Storage)     │ │
│   │     "diff_ids": [...]       │  │                                      │ │
│   │   }                         │  │                                      │ │
│   │  }                          │  │                                      │ │
│   └────────────────────────────┘  └─────────────────────────────────────┘ │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
\`\`\`

> **💡 팁 (Tip)**: \`skopeo inspect\` 명령으로 이미지를 다운로드하지 않고도 원격 레지스트리의 이미지 매니페스트를 확인할 수 있습니다. 이미지 크기와 레이어 구성을 미리 파악하는 데 유용합니다.

### 2.3. OCI Runtime Specification 상세

OCI 런타임 스펙은 컨테이너를 어떻게 생성하고 실행할지 정의합니다. 핵심은 **config.json** 파일입니다:

\`\`\`json
{
  "ociVersion": "1.0.2",
  "process": {
    "terminal": false,
    "user": { "uid": 0, "gid": 0 },
    "args": ["nginx", "-g", "daemon off;"],
    "env": [
      "PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin",
      "NGINX_VERSION=1.25.0"
    ],
    "cwd": "/",
    "capabilities": {
      "bounding": ["CAP_CHOWN", "CAP_NET_BIND_SERVICE"],
      "effective": ["CAP_CHOWN", "CAP_NET_BIND_SERVICE"]
    }
  },
  "root": {
    "path": "rootfs",
    "readonly": false
  },
  "hostname": "nginx-pod",
  "mounts": [
    { "destination": "/proc", "type": "proc", "source": "proc" },
    { "destination": "/dev", "type": "tmpfs", "source": "tmpfs" }
  ],
  "linux": {
    "namespaces": [
      { "type": "pid" },
      { "type": "network" },
      { "type": "ipc" },
      { "type": "uts" },
      { "type": "mount" }
    ],
    "resources": {
      "memory": { "limit": 268435456 },
      "cpu": { "shares": 512 }
    }
  }
}
\`\`\`

> **📝 예제 (Example)**: 위 config.json은 nginx 컨테이너의 실제 런타임 설정입니다. \`namespaces\` 배열에서 어떤 네임스페이스를 사용할지, \`resources\`에서 cgroups 제한을 어떻게 설정할지 정의합니다.

**컨테이너 생명주기:**

\`\`\`
┌─────────────────────────────────────────────────────────────────────────────┐
│                        OCI 컨테이너 생명주기                                  │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   ┌──────────┐    create    ┌──────────┐    start     ┌──────────┐        │
│   │          │─────────────►│          │─────────────►│          │        │
│   │  (none)  │              │ created  │              │ running  │        │
│   │          │              │          │              │          │        │
│   └──────────┘              └──────────┘              └────┬─────┘        │
│                                   │                        │               │
│                                   │ delete                 │ kill/stop     │
│                                   │                        │               │
│                                   ▼                        ▼               │
│                             ┌──────────┐              ┌──────────┐        │
│                             │          │◄─────────────│          │        │
│                             │ deleted  │    delete    │ stopped  │        │
│                             │          │              │          │        │
│                             └──────────┘              └──────────┘        │
│                                                                             │
│   각 상태에서 수행되는 작업:                                                  │
│   • create: 네임스페이스 생성, cgroups 설정, rootfs 마운트                   │
│   • start: 프로세스 실행 (entrypoint/cmd)                                   │
│   • stop/kill: SIGTERM/SIGKILL 전송, 프로세스 종료                          │
│   • delete: 네임스페이스 해제, cgroups 삭제, 리소스 정리                     │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
\`\`\`

### 2.4. OCI Distribution Specification 상세

OCI Distribution Spec은 레지스트리 API를 정의합니다. HTTP/HTTPS 기반의 RESTful API로, 모든 OCI 호환 레지스트리는 이 API를 구현합니다:

| 엔드포인트 | 메서드 | 용도 |
|-----------|--------|------|
| \`/v2/\` | GET | API 버전 확인 (인증 필요 여부 체크) |
| \`/v2/<name>/manifests/<reference>\` | GET | 매니페스트 다운로드 |
| \`/v2/<name>/manifests/<reference>\` | PUT | 매니페스트 업로드 |
| \`/v2/<name>/blobs/<digest>\` | GET | 레이어(blob) 다운로드 |
| \`/v2/<name>/blobs/<digest>\` | HEAD | 레이어 존재 여부 확인 |
| \`/v2/<name>/blobs/uploads/\` | POST | 레이어 업로드 시작 |
| \`/v2/<name>/tags/list\` | GET | 태그 목록 조회 |

\`\`\`bash
# OCI Distribution API 사용 예시

# 1. API 버전 확인
curl https://registry-1.docker.io/v2/

# 2. 인증 토큰 획득 (Docker Hub)
TOKEN=\$(curl -s "https://auth.docker.io/token?service=registry.docker.io&scope=repository:library/nginx:pull" | jq -r .token)

# 3. 매니페스트 가져오기
curl -H "Authorization: Bearer \$TOKEN" \
     -H "Accept: application/vnd.oci.image.manifest.v1+json" \
     https://registry-1.docker.io/v2/library/nginx/manifests/alpine

# 4. 특정 레이어 다운로드
curl -L -H "Authorization: Bearer \$TOKEN" \
     https://registry-1.docker.io/v2/library/nginx/blobs/sha256:abc123...
\`\`\`

> **🔍 심화 학습 (Deep Dive)**: Content-Addressable Storage(CAS)는 OCI 이미지의 핵심 개념입니다. 모든 컨텐츠(레이어, 설정, 매니페스트)는 SHA256 해시로 식별됩니다. 같은 해시 = 같은 내용이므로, 레이어 중복을 제거하고 무결성을 보장할 수 있습니다.

### 2.5. OCI 호환 도구 생태계

| 카테고리 | 도구 | 설명 |
|----------|------|------|
| **이미지 빌드** | Docker, Buildah, Kaniko, BuildKit | Dockerfile에서 OCI 이미지 생성 |
| **이미지 관리** | Skopeo | 레지스트리 간 이미지 복사, 검사 |
| **High-level 런타임** | containerd, CRI-O, Docker | CRI 구현, 이미지/컨테이너 관리 |
| **Low-level 런타임** | runc, crun, gVisor, Kata | OCI 런타임 스펙 구현체 |
| **레지스트리** | Docker Hub, Quay, Harbor, GHCR | OCI 이미지 저장/배포 |

### 섹션 요약

- OCI는 **Image, Runtime, Distribution** 세 가지 표준을 정의
- 이 표준 덕분에 **다양한 도구들이 상호 운용** 가능
- 이미지는 **매니페스트 + 설정 + 레이어**로 구성
- 모든 컨텐츠는 **SHA256 해시**로 식별 (Content-Addressable)

---

## 3. 컨테이너 런타임

### 3.1. 런타임 계층 구조의 이해

컨테이너 런타임은 왜 두 개의 계층으로 나뉘어 있을까요? 이것을 이해하려면 역사적 배경을 알아야 합니다.

초기 Docker는 모든 것을 하나의 데몬에서 처리했습니다: 이미지 빌드, 이미지 관리, 컨테이너 실행, API 제공... 하지만 이 "모놀리식" 구조는 문제가 있었습니다:

1. Docker 데몬이 재시작되면 모든 컨테이너가 영향을 받음
2. 보안 취약점이 발견되면 전체 시스템이 위험
3. Kubernetes 같은 오케스트레이터에서 불필요한 기능까지 포함

이 문제를 해결하기 위해 Docker는 containerd를 분리했고, 업계는 런타임을 두 계층으로 나누기 시작했습니다:

\`\`\`
┌─────────────────────────────────────────────────────────────────────────────┐
│                      컨테이너 런타임 계층                                    │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   Kubernetes                                                                │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │  kubelet                                                              │   │
│  │     │                                                                 │   │
│  │     │ CRI (Container Runtime Interface) - gRPC                       │   │
│  │     │ "Pod를 만들어줘", "컨테이너 상태 알려줘"                          │   │
│  │     ▼                                                                 │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│   High-Level Runtime (CRI 구현체) - "관리자"                                │
│  ┌────────────────────────┐     ┌────────────────────────┐                │
│  │     containerd         │     │       CRI-O           │                │
│  │                        │     │                        │                │
│  │  • 이미지 pull/push    │     │  • Kubernetes 전용     │                │
│  │  • 컨테이너 생명주기    │     │  • 더 경량화          │                │
│  │  • 스냅샷 관리         │     │  • Red Hat 주도        │                │
│  │  • 네트워크/스토리지   │     │                        │                │
│  │     │                  │     │     │                  │                │
│  │     │ OCI Runtime Spec │     │     │ OCI Runtime Spec │                │
│  │     │ "이 config.json  │     │     │                  │                │
│  │     │  대로 컨테이너    │     │     │                  │                │
│  │     │  만들어줘"       │     │     │                  │                │
│  │     ▼                  │     │     ▼                  │                │
│  └────────────────────────┘     └────────────────────────┘                │
│                                                                             │
│   Low-Level Runtime (OCI 구현체) - "실행자"                                 │
│  ┌────────────────┐  ┌────────────────┐  ┌────────────────┐               │
│  │     runc       │  │     crun       │  │    gVisor      │               │
│  │                │  │                │  │   (runsc)      │               │
│  │  • Go 구현     │  │  • C 구현      │  │                │               │
│  │  • 표준 구현체  │  │  • 더 빠름     │  │  • 커널 에뮬   │               │
│  │  • Docker/K8s  │  │  • 메모리 절약 │  │  • 강한 격리   │               │
│  │    기본값      │  │  • Podman 기본 │  │  • GCP 사용    │               │
│  └────────────────┘  └────────────────┘  └────────────────┘               │
│           │                  │                  │                          │
│           └──────────────────┴──────────────────┘                          │
│                              │                                             │
│                              ▼                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                      Linux Kernel                                     │   │
│  │              namespaces, cgroups, seccomp, capabilities              │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
\`\`\`

> **📘 개념 (Concept)**: High-level 런타임은 "무엇을 할지" 결정하고, Low-level 런타임은 "어떻게 할지" 실행합니다. containerd는 "nginx:alpine 이미지를 pull하고, 이 설정으로 컨테이너를 만들어"라고 지시하고, runc는 실제로 네임스페이스를 만들고 cgroups를 설정하고 프로세스를 시작합니다.

### 3.2. CRI (Container Runtime Interface) 상세

CRI는 Kubernetes 1.5에서 도입된 **kubelet과 컨테이너 런타임 간의 표준 인터페이스**입니다.

왜 CRI가 필요했을까요? 초기 Kubernetes는 Docker만 지원했습니다. Docker 지원 코드가 kubelet 내부에 하드코딩되어 있었죠. 하지만 rkt, containerd 등 새로운 런타임이 등장하면서, 각 런타임마다 kubelet을 수정해야 하는 문제가 생겼습니다.

CRI는 이 문제를 해결합니다. 런타임이 CRI를 구현하면, kubelet은 어떤 런타임이든 동일한 방식으로 통신할 수 있습니다.

\`\`\`
┌─────────────────────────────────────────────────────────────────────────────┐
│                              CRI API 구조                                    │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   RuntimeService (컨테이너/Pod 관리)          ImageService (이미지 관리)     │
│  ┌────────────────────────────────┐         ┌────────────────────────────┐ │
│  │                                │         │                            │ │
│  │  Pod Sandbox 관리:             │         │  • ListImages()            │ │
│  │  • RunPodSandbox()             │         │  • PullImage()             │ │
│  │  • StopPodSandbox()            │         │  • RemoveImage()           │ │
│  │  • RemovePodSandbox()          │         │  • ImageStatus()           │ │
│  │  • PodSandboxStatus()          │         │  • ImageFsInfo()           │ │
│  │  • ListPodSandbox()            │         │                            │ │
│  │                                │         └────────────────────────────┘ │
│  │  컨테이너 관리:                 │                                        │
│  │  • CreateContainer()           │         gRPC 통신 (Unix Socket)        │
│  │  • StartContainer()            │         /run/containerd/containerd.sock│
│  │  • StopContainer()             │         /var/run/crio/crio.sock        │
│  │  • RemoveContainer()           │                                        │
│  │  • ListContainers()            │                                        │
│  │  • ContainerStatus()           │                                        │
│  │  • UpdateContainerResources()  │                                        │
│  │                                │                                        │
│  │  실행/디버깅:                  │                                        │
│  │  • ExecSync()                  │                                        │
│  │  • Exec()                      │                                        │
│  │  • Attach()                    │                                        │
│  │  • PortForward()               │                                        │
│  │                                │                                        │
│  └────────────────────────────────┘                                        │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
\`\`\`

> **🔍 심화 학습 (Deep Dive)**: CRI에서 "Pod Sandbox"는 Pod의 네트워크 네임스페이스와 IPC 네임스페이스를 호스팅하는 특별한 컨테이너입니다. Kubernetes의 pause 컨테이너가 바로 이 역할을 합니다. Pod 내의 모든 컨테이너는 이 sandbox의 네임스페이스를 공유합니다.

**crictl로 CRI 사용하기:**

\`\`\`bash
# crictl은 CRI 호환 런타임과 통신하는 CLI 도구입니다

# 런타임 정보 확인
crictl info

# 이미지 목록
crictl images
# IMAGE                                      TAG       SIZE
# docker.io/library/nginx                    alpine    43.3MB
# registry.k8s.io/pause                      3.9       746kB

# 이미지 pull
crictl pull nginx:alpine

# Pod sandbox 목록
crictl pods
# POD ID              CREATED             STATE     NAME                        NAMESPACE
# a1b2c3d4e5f6        2 hours ago         Ready     nginx-deployment-xxx-yyy    default

# 컨테이너 목록
crictl ps
# CONTAINER           IMAGE               CREATED             STATE     NAME
# 9876543210ab        nginx:alpine        2 hours ago         Running   nginx

# 컨테이너 로그
crictl logs 9876543210ab

# 컨테이너 내부 실행
crictl exec -it 9876543210ab /bin/sh
\`\`\`

### 3.3. containerd vs CRI-O vs Docker 비교

| 항목 | containerd | CRI-O | Docker |
|------|-----------|-------|--------|
| **개발 주체** | CNCF (Docker 기부) | Red Hat, CNCF | Docker Inc. |
| **용도** | 범용 | Kubernetes 전용 | 개발/범용 |
| **CRI 지원** | 플러그인 (기본 활성화) | 네이티브 | dockershim (제거됨) |
| **이미지 빌드** | 별도 도구 필요 | 별도 도구 필요 | 내장 (docker build) |
| **CLI 도구** | ctr, nerdctl, crictl | crictl | docker |
| **메모리 사용** | 중간 | 낮음 | 높음 |
| **Kubernetes 호환** | 권장 | 권장 | 1.24부터 미지원 |

> **⚠️ 주의 (Warning)**: Kubernetes 1.24부터 dockershim이 제거되었습니다. Docker를 사용하려면 cri-dockerd 어댑터가 필요합니다. 신규 클러스터는 containerd나 CRI-O를 사용하세요.

### 3.4. Low-level 런타임 비교

| 런타임 | 언어 | 특징 | 사용 사례 |
|--------|------|------|----------|
| **runc** | Go | OCI 표준 구현체, 안정적 | 대부분의 환경 (기본값) |
| **crun** | C | 빠른 시작, 낮은 메모리 | 리소스 제한 환경, Podman |
| **gVisor** | Go | 커널 syscall 필터링 | 멀티테넌트, 보안 중시 |
| **Kata Containers** | Go | 경량 VM 기반 격리 | 강한 격리 필요 시 |
| **Firecracker** | Rust | microVM, AWS Lambda | 서버리스, FaaS |

\`\`\`bash
# 런타임 확인
crictl info | grep -A 5 "runtimes"

# runc 버전 확인
runc --version
# runc version 1.1.12
# spec: 1.0.2-dev
# go: go1.21.0
# libseccomp: 2.5.4
\`\`\`

### 섹션 요약

- 컨테이너 런타임은 **High-level(관리자)**과 **Low-level(실행자)**로 구분
- **CRI**는 Kubernetes와 런타임 간의 표준 인터페이스
- **containerd**는 가장 널리 사용되는 CRI 구현체
- **containerd-shim**이 containerd와 컨테이너를 분리하여 안정성 보장
- Kubernetes 1.24부터 **Docker 직접 지원 제거**, containerd/CRI-O 권장

---

## 4. 컨테이너 이미지

### 4.1. 이미지 구조 상세

OCI 이미지는 **레이어(Layer)** 구조로 되어 있습니다. 각 레이어는 이전 레이어 위에 쌓이는 파일 시스템 변경 사항입니다.

\`\`\`
┌─────────────────────────────────────────────────────────────────────────────┐
│                         OCI 이미지 구조 상세                                  │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   이미지: nginx:1.25-alpine                                                 │
│                                                                             │
│   ┌─────────────────────────────────────────────────────────────────────┐  │
│   │                     Image Manifest                                   │  │
│   │  {                                                                   │  │
│   │    "schemaVersion": 2,                                              │  │
│   │    "mediaType": "application/vnd.oci.image.manifest.v1+json",       │  │
│   │    "config": { "digest": "sha256:abc123..." },                      │  │
│   │    "layers": [                                                       │  │
│   │      { "digest": "sha256:layer1...", "size": 3408129 },             │  │
│   │      { "digest": "sha256:layer2...", "size": 1234567 },             │  │
│   │      { "digest": "sha256:layer3...", "size": 567890 }               │  │
│   │    ]                                                                 │  │
│   │  }                                                                   │  │
│   └─────────────────────────────────────────────────────────────────────┘  │
│                                     │                                      │
│                    ┌────────────────┴────────────────┐                     │
│                    │                                 │                     │
│                    ▼                                 ▼                     │
│   ┌─────────────────────────┐     ┌─────────────────────────────────────┐ │
│   │    Image Config         │     │           Layers                     │ │
│   │  {                      │     │                                      │ │
│   │   "architecture": "amd64"│    │  Layer 3: nginx config (567KB)      │ │
│   │   "os": "linux",        │     │  ┌──────────────────────────────┐   │ │
│   │   "config": {           │     │  │ /etc/nginx/nginx.conf        │   │ │
│   │     "Env": [            │     │  │ /usr/share/nginx/html/       │   │ │
│   │       "NGINX_VERSION=..." │   │  └──────────────────────────────┘   │ │
│   │     ],                   │    │              │                       │ │
│   │     "Cmd": ["nginx"...]  │    │  Layer 2: nginx binaries (1.2MB)    │ │
│   │   },                     │    │  ┌──────────────────────────────┐   │ │
│   │   "rootfs": {           │     │  │ /usr/sbin/nginx              │   │ │
│   │     "type": "layers",   │     │  │ /usr/lib/nginx/              │   │ │
│   │     "diff_ids": [...]   │     │  └──────────────────────────────┘   │ │
│   │   }                     │     │              │                       │ │
│   │  }                      │     │  Layer 1: alpine base (3.4MB)       │ │
│   └─────────────────────────┘     │  ┌──────────────────────────────┐   │ │
│                                    │  │ /bin/sh, /lib/libc.musl...   │   │ │
│                                    │  │ /etc/alpine-release          │   │ │
│                                    │  └──────────────────────────────┘   │ │
│                                    └─────────────────────────────────────┘ │
│                                                                             │
│   레이어 특징:                                                              │
│   • 각 레이어는 tar.gz 아카이브 (gzip 또는 zstd 압축)                       │
│   • 레이어는 읽기 전용 (immutable)                                          │
│   • 레이어는 공유 가능 (content-addressable)                                │
│   • digest = sha256 해시값으로 고유 식별                                    │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
\`\`\`

> **📘 개념 (Concept)**: 레이어가 **읽기 전용**이고 **Content-Addressable**한 것은 매우 중요한 특성입니다. 같은 베이스 이미지(예: alpine:3.18)를 사용하는 여러 이미지가 있으면, 베이스 레이어를 한 번만 저장하면 됩니다. 이것이 컨테이너 이미지가 효율적인 이유입니다.

### 4.2. 이미지 레이어와 overlayfs

컨테이너가 실행되면 읽기 전용 이미지 레이어 위에 쓰기 가능한 컨테이너 레이어가 추가됩니다. 이것을 가능하게 하는 것이 **overlayfs**입니다.

\`\`\`
┌─────────────────────────────────────────────────────────────────────────────┐
│                         overlayfs 동작 원리                                  │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   overlayfs mount:                                                          │
│   mount -t overlay overlay -o                                               │
│     lowerdir=/layer3:/layer2:/layer1,                                       │
│     upperdir=/container-layer,                                              │
│     workdir=/work                                                           │
│     /merged                                                                 │
│                                                                             │
│   ┌─────────────────────────────────────────────────────────────────────┐  │
│   │                    Merged View (컨테이너가 보는 파일시스템)           │  │
│   │                           /merged                                    │  │
│   │                                                                       │  │
│   │   /bin/sh          ← Layer 1 (alpine)                                │  │
│   │   /etc/nginx/      ← Layer 3 (nginx config)                          │  │
│   │   /usr/sbin/nginx  ← Layer 2 (nginx binary)                          │  │
│   │   /app/myconfig    ← Container Layer (새로 생성)                     │  │
│   │   /var/log/nginx/  ← Container Layer (수정됨)                        │  │
│   │                                                                       │  │
│   └─────────────────────────────────────────────────────────────────────┘  │
│                                      │                                      │
│   ┌─────────────────────────────────────────────────────────────────────┐  │
│   │                    Upper Layer (R/W, 컨테이너 레이어)                 │  │
│   │                         /container-layer                             │  │
│   │                                                                       │  │
│   │   /app/myconfig    (새로 생성된 파일)                                │  │
│   │   /var/log/nginx/access.log (수정된 파일 - 복사됨)                   │  │
│   │   /etc/motd        (삭제 마커 - whiteout)                            │  │
│   │                                                                       │  │
│   └─────────────────────────────────────────────────────────────────────┘  │
│                                      │                                      │
│   ┌─────────────────────────────────────────────────────────────────────┐  │
│   │                 Lower Layers (Read-Only, 이미지 레이어들)            │  │
│   │                                                                       │  │
│   │   Layer 3: /etc/nginx/nginx.conf, /usr/share/nginx/html/            │  │
│   │   Layer 2: /usr/sbin/nginx, /usr/lib/nginx/                         │  │
│   │   Layer 1: /bin/sh, /lib/libc.musl.so.1, /etc/alpine-release        │  │
│   │                                                                       │  │
│   └─────────────────────────────────────────────────────────────────────┘  │
│                                                                             │
│   Copy-on-Write (CoW) 동작:                                                 │
│   ┌─────────────────────────────────────────────────────────────────────┐  │
│   │                                                                       │  │
│   │   읽기 (READ):                                                        │  │
│   │     1. Upper에서 찾기 → 있으면 반환                                   │  │
│   │     2. 없으면 Lower에서 찾기 → 반환                                   │  │
│   │                                                                       │  │
│   │   쓰기 (WRITE):                                                       │  │
│   │     1. Upper에 이미 있으면 → 직접 수정                                │  │
│   │     2. Lower에만 있으면 → Upper로 복사 후 수정 (copy-up)             │  │
│   │     3. 새 파일이면 → Upper에 생성                                     │  │
│   │                                                                       │  │
│   │   삭제 (DELETE):                                                      │  │
│   │     1. Upper에 whiteout 파일 생성 (character device 0,0)             │  │
│   │     2. Lower의 파일은 실제로 삭제되지 않음                            │  │
│   │                                                                       │  │
│   └─────────────────────────────────────────────────────────────────────┘  │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
\`\`\`

> **💡 팁 (Tip)**: 컨테이너 내에서 큰 파일을 수정하면 copy-up이 발생하여 성능이 저하될 수 있습니다. 데이터베이스 파일처럼 자주 수정되는 큰 파일은 **볼륨 마운트**를 사용하여 overlayfs를 우회하세요.

**실제 overlayfs 확인:**

\`\`\`bash
# containerd의 overlayfs 마운트 확인
mount | grep overlay
# overlay on /run/containerd/.../rootfs type overlay (rw,relatime,lowerdir=...,upperdir=...,workdir=...)

# 스냅샷 디렉토리 구조 확인
ls -la /var/lib/containerd/io.containerd.snapshotter.v1.overlayfs/snapshots/
# 1/  2/  3/  4/  ...  (각 레이어별 디렉토리)

# 특정 컨테이너의 마운트 정보
crictl inspect <container-id> | jq '.info.runtimeSpec.mounts'
\`\`\`

### 4.3. 이미지 이름과 태그

이미지 참조(Image Reference)는 여러 구성 요소로 이루어집니다:

\`\`\`
┌─────────────────────────────────────────────────────────────────────────────┐
│                         이미지 참조 형식                                     │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   완전한 형식: [registry/][namespace/]name[:tag][@digest]                   │
│                                                                             │
│   예시 분석:                                                                │
│                                                                             │
│   ┌─────────────────────────────────────────────────────────────────────┐  │
│   │  quay.io/cilium/cilium:v1.18.4                                      │  │
│   │  ───────  ──────  ──────  ───────                                   │  │
│   │  registry namespace name   tag                                       │  │
│   └─────────────────────────────────────────────────────────────────────┘  │
│                                                                             │
│   ┌─────────────────────────────────────────────────────────────────────┐  │
│   │  registry.k8s.io/kube-apiserver:v1.33.7                             │  │
│   │  ──────────────  ──────────────  ──────                             │  │
│   │  registry        name            tag                                 │  │
│   │  (namespace 없음 = 루트 레벨 이미지)                                 │  │
│   └─────────────────────────────────────────────────────────────────────┘  │
│                                                                             │
│   ┌─────────────────────────────────────────────────────────────────────┐  │
│   │  nginx                                                               │  │
│   │  → docker.io/library/nginx:latest (기본값 적용)                     │  │
│   │                                                                       │  │
│   │  nginx:1.25-alpine                                                   │  │
│   │  → docker.io/library/nginx:1.25-alpine                              │  │
│   └─────────────────────────────────────────────────────────────────────┘  │
│                                                                             │
│   Digest 참조 (불변):                                                       │
│   nginx@sha256:abc123def456...                                             │  │
│   → 태그와 달리 digest는 절대 변경되지 않음                                 │
│   → 프로덕션에서 재현성이 필요할 때 사용                                    │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
\`\`\`

> **⚠️ 주의 (Warning)**: \`latest\` 태그는 "가장 최신"을 의미하지 않습니다. 단지 태그를 생략했을 때의 기본값일 뿐입니다. 프로덕션에서는 항상 **명시적인 버전 태그** 또는 **digest**를 사용하세요.

### 4.4. 이미지 검사 명령어

\`\`\`bash
# crictl로 로컬 이미지 검사
crictl inspecti nginx:alpine | jq '.info.imageSpec'

# Skopeo로 원격 이미지 검사 (다운로드 없이)
skopeo inspect docker://docker.io/library/nginx:alpine

# 멀티 아키텍처 이미지의 매니페스트 리스트 확인
skopeo inspect --raw docker://docker.io/library/nginx:alpine | jq .

# 특정 아키텍처 매니페스트 확인
skopeo inspect --raw docker://docker.io/library/nginx:alpine \\
  --override-arch amd64 --override-os linux | jq .

# 이미지 레이어 크기 확인
skopeo inspect docker://nginx:alpine | jq '.Layers'
\`\`\`

### 섹션 요약

- OCI 이미지는 **매니페스트 + 설정 + 레이어**로 구성
- 레이어는 **읽기 전용**이고 **Content-Addressable** (SHA256 해시)
- **overlayfs**가 이미지 레이어 위에 쓰기 가능한 컨테이너 레이어 제공
- **Copy-on-Write**로 효율적인 스토리지 사용
- 프로덕션에서는 **명시적 태그** 또는 **digest** 사용 권장

---

## 5. 이미지 레지스트리

### 5.1. 레지스트리 아키텍처

컨테이너 이미지 레지스트리는 OCI Distribution Spec을 구현한 HTTP 서버입니다. 이미지를 저장하고 배포하는 역할을 합니다.

\`\`\`
┌─────────────────────────────────────────────────────────────────────────────┐
│                        레지스트리 아키텍처                                   │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   Client (containerd, podman, skopeo)                                      │
│       │                                                                     │
│       │ HTTPS (OCI Distribution API)                                       │
│       ▼                                                                     │
│   ┌─────────────────────────────────────────────────────────────────────┐  │
│   │                    Container Registry                                │  │
│   │                                                                       │  │
│   │   ┌───────────────────────────────────────────────────────────────┐ │  │
│   │   │                        API Layer                               │ │  │
│   │   │                                                                 │ │  │
│   │   │   /v2/                           API 버전 확인                  │ │  │
│   │   │   /v2/<name>/manifests/<ref>     매니페스트 GET/PUT             │ │  │
│   │   │   /v2/<name>/blobs/<digest>      Blob GET (레이어 다운로드)     │ │  │
│   │   │   /v2/<name>/blobs/uploads/      Blob 업로드 시작              │ │  │
│   │   │   /v2/<name>/tags/list           태그 목록                      │ │  │
│   │   │                                                                 │ │  │
│   │   └───────────────────────────────────────────────────────────────┘ │  │
│   │                              │                                       │  │
│   │                              ▼                                       │  │
│   │   ┌───────────────────────────────────────────────────────────────┐ │  │
│   │   │                    Storage Backend                             │ │  │
│   │   │                                                                 │ │  │
│   │   │   /v2/repositories/                                            │ │  │
│   │   │   └── library/                                                 │ │  │
│   │   │       └── nginx/                                               │ │  │
│   │   │           ├── _manifests/                                      │ │  │
│   │   │           │   ├── revisions/sha256/<hash>/link                 │ │  │
│   │   │           │   └── tags/                                        │ │  │
│   │   │           │       ├── latest/current/link                      │ │  │
│   │   │           │       └── 1.25-alpine/current/link                 │ │  │
│   │   │           └── _layers/sha256/                                  │ │  │
│   │   │               └── <digest>/link                                │ │  │
│   │   │                                                                 │ │  │
│   │   │   /v2/blobs/sha256/                                            │ │  │
│   │   │   └── ab/abc123.../data   (실제 blob 데이터)                   │ │  │
│   │   │                                                                 │ │  │
│   │   └───────────────────────────────────────────────────────────────┘ │  │
│   │                                                                       │  │
│   └─────────────────────────────────────────────────────────────────────┘  │
│                                                                             │
│   Storage 옵션:                                                             │
│   • 로컬 파일시스템                                                         │
│   • S3, GCS, Azure Blob (클라우드 오브젝트 스토리지)                        │
│   • Swift (OpenStack)                                                       │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
\`\`\`

### 5.2. 주요 레지스트리 서비스

| 레지스트리 | URL | 특징 | 비용 |
|-----------|-----|------|------|
| **Docker Hub** | docker.io | 공식 이미지, 가장 큰 생태계 | 무료 (rate limit), 유료 |
| **Quay.io** | quay.io | Red Hat 운영, Cilium 이미지 | 무료, 유료 |
| **GHCR** | ghcr.io | GitHub 통합, Actions 연동 | 무료 (공개), 유료 |
| **registry.k8s.io** | registry.k8s.io | Kubernetes 공식 이미지 | 무료 |
| **Amazon ECR** | <account>.dkr.ecr.<region>.amazonaws.com | AWS 통합 | 유료 |
| **Google GCR/AR** | gcr.io, <region>-docker.pkg.dev | GCP 통합 | 유료 |
| **Azure ACR** | <name>.azurecr.io | Azure 통합 | 유료 |
| **Harbor** | self-hosted | 오픈소스, 보안 기능 | 무료 (자체 호스팅) |
| **Registry:2** | self-hosted | 단순, 경량 | 무료 (자체 호스팅) |

> **📘 개념 (Concept)**: 2023년부터 Kubernetes 공식 이미지가 \`k8s.gcr.io\`에서 \`registry.k8s.io\`로 이전되었습니다. 새로운 레지스트리는 CDN 기반으로 더 빠르고 안정적입니다.

### 5.3. 프록시 레지스트리

폐쇄망 환경에서는 외부 레지스트리에 직접 접근할 수 없습니다. 프록시 레지스트리는 이 문제를 해결합니다:

\`\`\`
┌─────────────────────────────────────────────────────────────────────────────┐
│                      프록시 레지스트리 동작                                  │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   폐쇄망 환경                                            │ 인터넷          │
│                                                          │                 │
│   containerd                Proxy Registry               │  원본 Registry  │
│  ┌─────────────┐         ┌─────────────────┐            │ ┌─────────────┐ │
│  │             │────────►│ :5000           │────────────│►│ docker.io   │ │
│  │ pull nginx  │  요청   │ (docker proxy)  │  캐시 miss │ │             │ │
│  │             │         │                 │            │ └─────────────┘ │
│  └─────────────┘         │  ┌───────────┐  │            │                 │
│       ▲                  │  │  Cache    │  │            │                 │
│       │                  │  │ (로컬저장) │  │            │                 │
│       │          ◄───────│  │           │◄─│────────────│                 │
│       │           응답   │  └───────────┘  │    응답    │                 │
│       │                  └─────────────────┘            │                 │
│       │                                                  │                 │
│       │  캐시 hit 시 원본 레지스트리 접근 없이 즉시 응답   │                 │
│       └──────────────────────────────────────────────────┘                 │
│                                                                             │
│   Pull-through Cache 동작:                                                  │
│   ┌─────────────────────────────────────────────────────────────────────┐  │
│   │  1. 클라이언트: nginx:alpine 요청                                    │  │
│   │  2. 프록시: 로컬 캐시 확인                                           │  │
│   │     ├─ 캐시 있음 → 즉시 응답 (오프라인 가능)                         │  │
│   │     └─ 캐시 없음 → 원본에서 다운로드 → 캐시 저장 → 응답              │  │
│   │  3. 이후 동일 요청: 캐시에서 응답 (빠름)                              │  │
│   │                                                                       │  │
│   │  주의: tag는 변경될 수 있으므로 TTL 설정 필요                         │  │
│   │        digest 기반 요청은 영구 캐시 가능                              │  │
│   └─────────────────────────────────────────────────────────────────────┘  │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
\`\`\`

**Registry:2 프록시 설정 예시:**

\`\`\`yaml
# /etc/docker-registry/config.yml
version: 0.1
log:
  level: info
storage:
  filesystem:
    rootdirectory: /var/lib/registry
  delete:
    enabled: true
http:
  addr: :5000
  headers:
    X-Content-Type-Options: [nosniff]
proxy:
  remoteurl: https://registry-1.docker.io
  username: ""  # Docker Hub 인증 (선택)
  password: ""
\`\`\`

\`\`\`bash
# Podman으로 프록시 레지스트리 실행
podman run -d \\
  --name registry-proxy-docker \\
  -p 5000:5000 \\
  -v /opt/registry/docker:/var/lib/registry \\
  -v /opt/registry/config-docker.yml:/etc/docker/registry/config.yml \\
  docker.io/library/registry:2
\`\`\`

### 5.4. containerd 레지스트리 미러 설정

containerd가 프록시 레지스트리를 사용하도록 설정하려면:

\`\`\`toml
# /etc/containerd/config.toml
version = 2

[plugins."io.containerd.grpc.v1.cri".registry]
  [plugins."io.containerd.grpc.v1.cri".registry.mirrors]
    # docker.io 미러 설정
    [plugins."io.containerd.grpc.v1.cri".registry.mirrors."docker.io"]
      endpoint = ["http://192.168.108.201:5000"]
    
    # quay.io 미러 설정
    [plugins."io.containerd.grpc.v1.cri".registry.mirrors."quay.io"]
      endpoint = ["http://192.168.108.201:5001"]
    
    # registry.k8s.io 미러 설정
    [plugins."io.containerd.grpc.v1.cri".registry.mirrors."registry.k8s.io"]
      endpoint = ["http://192.168.108.201:5003"]

  # HTTP 레지스트리 허용 (HTTPS가 아닌 경우)
  [plugins."io.containerd.grpc.v1.cri".registry.configs]
    [plugins."io.containerd.grpc.v1.cri".registry.configs."192.168.108.201:5000".tls]
      insecure_skip_verify = true
\`\`\`

\`\`\`bash
# 설정 적용
systemctl restart containerd

# 미러 동작 확인
crictl pull nginx:alpine
# 로그에서 192.168.108.201:5000으로 요청하는 것 확인
\`\`\`

> **💡 팁 (Tip)**: 프록시 레지스트리를 사용할 때 \`insecure_skip_verify = true\`는 개발/테스트 환경에서만 사용하세요. 프로덕션에서는 적절한 TLS 인증서를 설정해야 합니다.

### 섹션 요약

- 레지스트리는 **OCI Distribution Spec** 기반의 HTTP 서버
- 주요 공용 레지스트리: **Docker Hub, Quay, GHCR, registry.k8s.io**
- 폐쇄망에서는 **프록시 레지스트리**로 이미지 캐싱
- containerd **registry.mirrors** 설정으로 미러 사용

---

## 6. containerd 심화

### 6.1. containerd 아키텍처 상세

\`\`\`
┌─────────────────────────────────────────────────────────────────────────────┐
│                       containerd 내부 아키텍처                                │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   클라이언트 (kubelet, ctr, nerdctl, crictl)                                │
│       │                                                                     │
│       │ gRPC                                                                │
│       ▼                                                                     │
│   containerd                                                                │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                                                                       │   │
│  │  ┌───────────────────────────────────────────────────────────────┐   │   │
│  │  │                         CRI Plugin                             │   │   │
│  │  │   Kubernetes CRI 구현 (기본 활성화)                            │   │   │
│  │  │   Pod 개념 이해, sandbox 관리                                  │   │   │
│  │  └───────────────────────────────────────────────────────────────┘   │   │
│  │                              │                                       │   │
│  │       ┌──────────────────────┼──────────────────────┐               │   │
│  │       ▼                      ▼                      ▼               │   │
│  │  ┌─────────────┐      ┌─────────────┐      ┌─────────────┐         │   │
│  │  │   Images    │      │ Containers  │      │  Snapshots  │         │   │
│  │  │   Service   │      │   Service   │      │   Service   │         │   │
│  │  │             │      │             │      │             │         │   │
│  │  │ • Pull      │      │ • Create    │      │ • Prepare   │         │   │
│  │  │ • Push      │      │ • Start     │      │ • Commit    │         │   │
│  │  │ • Unpack    │      │ • Stop      │      │ • Remove    │         │   │
│  │  │ • Export    │      │ • Delete    │      │ • View      │         │   │
│  │  └─────────────┘      └─────────────┘      └─────────────┘         │   │
│  │       │                      │                      │               │   │
│  │       └──────────────────────┴──────────────────────┘               │   │
│  │                              │                                       │   │
│  │                              ▼                                       │   │
│  │  ┌───────────────────────────────────────────────────────────────┐   │   │
│  │  │                      Content Store                             │   │   │
│  │  │   /var/lib/containerd/io.containerd.content.v1.content/       │   │   │
│  │  │   모든 이미지 레이어, 설정 파일 저장 (Content-Addressable)      │   │   │
│  │  └───────────────────────────────────────────────────────────────┘   │   │
│  │                              │                                       │   │
│  │                              ▼                                       │   │
│  │  ┌───────────────────────────────────────────────────────────────┐   │   │
│  │  │                    Snapshotter                                 │   │   │
│  │  │   overlayfs (기본), native, btrfs, zfs, devmapper             │   │   │
│  │  │   /var/lib/containerd/io.containerd.snapshotter.v1.overlayfs/ │   │   │
│  │  └───────────────────────────────────────────────────────────────┘   │   │
│  │                              │                                       │   │
│  │                              ▼                                       │   │
│  │  ┌───────────────────────────────────────────────────────────────┐   │   │
│  │  │                         Shim                                   │   │   │
│  │  │   containerd-shim-runc-v2                                     │   │   │
│  │  │   • containerd와 컨테이너 프로세스 분리                        │   │   │
│  │  │   • containerd 재시작해도 컨테이너 유지                        │   │   │
│  │  │   • 각 컨테이너마다 하나의 shim 프로세스                       │   │   │
│  │  └───────────────────────────────────────────────────────────────┘   │   │
│  │                              │                                       │   │
│  │                              ▼                                       │   │
│  │  ┌───────────────────────────────────────────────────────────────┐   │   │
│  │  │                         runc                                   │   │   │
│  │  │   OCI 런타임 스펙 구현, 실제 컨테이너 생성                      │   │   │
│  │  └───────────────────────────────────────────────────────────────┘   │   │
│  │                                                                       │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
\`\`\`

> **💡 팁 (Tip)**: containerd-shim의 역할은 매우 중요합니다. shim이 있기 때문에 containerd를 업그레이드해도 실행 중인 컨테이너에 영향이 없습니다. 프로덕션 환경에서 런타임 업그레이드를 안전하게 수행할 수 있는 이유입니다.

### 6.2. containerd 디렉토리 구조

\`\`\`
/var/lib/containerd/
├── io.containerd.content.v1.content/     # Content Store
│   ├── blobs/sha256/                     # 실제 blob 데이터
│   └── ingest/                           # 업로드 중인 데이터
│
├── io.containerd.snapshotter.v1.overlayfs/  # Snapshotter
│   └── snapshots/                        # 레이어 스냅샷
│       ├── 1/                            # 레이어 1
│       ├── 2/                            # 레이어 2
│       └── ...
│
├── io.containerd.metadata.v1.bolt/       # 메타데이터 DB
│   └── meta.db                           # BoltDB 파일
│
├── io.containerd.runtime.v2.task/        # 실행 중인 태스크
│   └── k8s.io/                           # Kubernetes 네임스페이스
│       └── <container-id>/
│           ├── rootfs/                   # 컨테이너 루트 파일시스템
│           ├── config.json               # OCI 런타임 설정
│           └── log.json                  # 컨테이너 로그
│
└── io.containerd.grpc.v1.cri/            # CRI 플러그인 데이터
    ├── containers/                        # 컨테이너 메타데이터
    └── sandboxes/                         # Pod sandbox 메타데이터
\`\`\`

### 6.3. ctr 명령어 활용

\`ctr\`은 containerd의 저수준 CLI 도구입니다. 디버깅과 문제 해결에 유용합니다:

\`\`\`bash
# 네임스페이스 목록 (k8s.io는 Kubernetes가 사용)
ctr namespaces list
# NAME   LABELS
# k8s.io

# 이미지 목록 (특정 네임스페이스)
ctr -n k8s.io images list

# 이미지 pull
ctr -n k8s.io images pull docker.io/library/nginx:alpine

# 컨테이너 목록
ctr -n k8s.io containers list

# 태스크(실행 중인 컨테이너) 목록
ctr -n k8s.io tasks list

# Content Store 내용 확인
ctr content list

# 스냅샷 목록
ctr -n k8s.io snapshots list

# 이미지 내보내기
ctr -n k8s.io images export nginx.tar docker.io/library/nginx:alpine

# 이미지 가져오기
ctr -n k8s.io images import nginx.tar
\`\`\`

> **📝 예제 (Example)**: Kubernetes 환경에서 containerd를 디버깅할 때는 항상 \`-n k8s.io\` 옵션을 사용하세요. Kubernetes는 \`k8s.io\` 네임스페이스에서 컨테이너를 관리합니다.

### 6.4. 문제 해결 가이드

**이미지 Pull 실패:**

\`\`\`bash
# 1. containerd 로그 확인
journalctl -u containerd -f

# 2. 레지스트리 연결 테스트
curl -v https://registry-1.docker.io/v2/

# 3. 프록시 설정 확인
cat /etc/containerd/config.toml | grep -A 10 "registry"

# 4. DNS 확인
nslookup registry-1.docker.io

# 5. 인증 정보 확인 (private registry)
cat /etc/containerd/config.toml | grep -A 5 "auth"
\`\`\`

**컨테이너 시작 실패:**

\`\`\`bash
# 1. 컨테이너 상태 확인
crictl ps -a

# 2. 컨테이너 로그 확인
crictl logs <container-id>

# 3. 컨테이너 상세 정보
crictl inspect <container-id>

# 4. Pod sandbox 상태 확인
crictl pods

# 5. kubelet 로그 확인
journalctl -u kubelet -f

# 6. OCI 런타임(runc) 직접 확인
runc list
runc state <container-id>
\`\`\`

**스토리지 문제:**

\`\`\`bash
# 1. 디스크 사용량 확인
df -h /var/lib/containerd

# 2. 이미지 정리
crictl rmi --prune

# 3. 사용하지 않는 스냅샷 정리
ctr -n k8s.io snapshots list
ctr -n k8s.io snapshots rm <snapshot-key>

# 4. Content Store 정리
ctr content list
ctr content rm <digest>

# 5. 전체 정리 (Kubernetes garbage collection)
# kubelet이 자동으로 수행, 수동 실행:
crictl rmi --prune
\`\`\`

### 섹션 요약

- containerd는 **Content Store, Snapshotter, Metadata DB** 등으로 구성
- \`ctr\`은 containerd 저수준 CLI, \`-n k8s.io\`로 Kubernetes 네임스페이스 접근
- 문제 해결 시 **로그, 설정, 네트워크 연결** 순서로 확인
- 스토리지 문제는 **이미지 정리**와 **스냅샷 정리**로 해결

---

## 이 장의 요약

이 장에서는 컨테이너의 핵심 개념부터 실제 구현까지 깊이 있게 살펴보았습니다.

### 핵심 개념 정리

| 개념 | 설명 | Kubernetes에서의 역할 |
|------|------|---------------------|
| **OCI 표준** | Image, Runtime, Distribution 표준 | 다양한 도구 상호운용성 |
| **containerd** | High-level 런타임 (CRI 구현) | kubelet과 통신, 컨테이너 관리 |
| **runc** | Low-level 런타임 (OCI 구현) | 실제 컨테이너 생성/실행 |
| **CRI** | Kubernetes-런타임 인터페이스 | kubelet의 표준 API |
| **이미지 레이어** | 읽기 전용, Content-Addressable | 효율적인 스토리지 |
| **overlayfs** | Copy-on-Write 파일시스템 | 컨테이너 파일시스템 |
| **레지스트리** | 이미지 저장/배포 서버 | 이미지 pull 소스 |

### 기억해야 할 핵심 포인트

1. **컨테이너는 VM이 아니다**: 호스트 커널을 공유하는 격리된 프로세스
2. **OCI 표준이 상호운용성을 보장**: Docker, Podman, containerd 간 이미지 호환
3. **런타임은 두 계층**: containerd(관리) + runc(실행)
4. **이미지 레이어는 불변**: 같은 레이어는 여러 이미지가 공유
5. **프록시 레지스트리로 폐쇄망 지원**: 이미지 캐싱으로 오프라인 배포

---

## 실습 과제

### 과제 1: 이미지 레이어 분석

nginx:alpine 이미지의 레이어 구조를 분석하세요.

\`\`\`bash
# 힌트
skopeo inspect docker://docker.io/library/nginx:alpine
crictl inspecti nginx:alpine | jq '.info.imageSpec.rootfs'
\`\`\`

**목표**: 각 레이어의 크기와 역할을 파악하고, Dockerfile 명령어와 매핑해보기

### 과제 2: 프록시 레지스트리 구축

Registry:2를 사용하여 docker.io 프록시 레지스트리를 구축하세요.

**요구사항**:
1. Podman으로 레지스트리 컨테이너 실행
2. docker.io를 원격 URL로 설정
3. nginx:alpine 이미지 pull 테스트
4. 캐시 동작 확인 (두 번째 pull이 더 빠른지)

### 과제 3: containerd 트러블슈팅

다음 시나리오를 해결하세요:

\`\`\`
시나리오: Pod가 ImagePullBackOff 상태입니다.
이미지: myregistry.internal:5000/myapp:v1.0
오류: "failed to pull image: unexpected status code 401"
\`\`\`

**해결 순서**:
1. 오류의 원인 파악
2. 필요한 설정 확인
3. 해결 방법 제시

### 과제 4: 이미지 최적화

다음 Dockerfile을 최적화하여 이미지 크기를 줄이세요:

\`\`\`dockerfile
FROM ubuntu:22.04
RUN apt-get update
RUN apt-get install -y python3 python3-pip
RUN pip3 install flask gunicorn
COPY requirements.txt /app/
RUN pip3 install -r /app/requirements.txt
COPY . /app/
RUN apt-get clean
WORKDIR /app
CMD ["gunicorn", "-b", "0.0.0.0:8000", "app:app"]
\`\`\`

**목표**: 레이어 수 줄이기, 이미지 크기 최소화, 빌드 캐시 활용

### 과제 5: CRI API 탐험

crictl을 사용하여 다음 정보를 수집하세요:

1. 현재 노드의 모든 Pod sandbox 목록
2. 특정 Pod 내의 모든 컨테이너
3. 컨테이너의 리소스 사용량 (CPU, Memory)
4. 컨테이너의 환경 변수와 마운트 정보

---

## 학습 점검

### 질문 1: OCI 표준
OCI가 정의하는 세 가지 표준과 각각의 역할을 설명하세요.

<details>
<summary>정답 보기</summary>

1. **OCI Image Specification**: 이미지 형식 정의 (매니페스트, 설정, 레이어)
2. **OCI Runtime Specification**: 컨테이너 실행 방법 정의 (config.json, 생명주기)
3. **OCI Distribution Specification**: 레지스트리 API 정의 (push/pull 프로토콜)

이 표준들 덕분에 Docker로 빌드한 이미지를 Podman으로 실행하고, Harbor에 저장할 수 있습니다.
</details>

### 질문 2: 런타임 계층
containerd와 runc의 역할 차이를 설명하세요.

<details>
<summary>정답 보기</summary>

**containerd (High-level Runtime)**:
- Kubernetes CRI 구현
- 이미지 pull/push 관리
- 컨테이너 생명주기 관리
- 스냅샷(파일시스템) 관리
- "무엇을 할지" 결정

**runc (Low-level Runtime)**:
- OCI Runtime Spec 구현
- 실제 네임스페이스 생성
- cgroups 설정
- 프로세스 시작
- "어떻게 할지" 실행

containerd가 runc에게 config.json을 전달하면, runc가 실제 컨테이너를 생성합니다.
</details>

### 질문 3: Copy-on-Write
overlayfs의 Copy-on-Write 동작을 설명하세요. 컨테이너에서 /etc/hosts 파일을 수정하면 어떤 일이 일어나나요?

<details>
<summary>정답 보기</summary>

**Copy-on-Write 동작**:
1. /etc/hosts는 이미지 레이어(lower)에 있음 (읽기 전용)
2. 컨테이너가 수정을 시도하면 "copy-up" 발생
3. 파일이 컨테이너 레이어(upper)로 복사됨
4. 복사된 파일에서 수정 수행
5. 이후 읽기도 upper의 수정된 버전 반환
6. 원본 이미지 레이어는 변경되지 않음

이 방식 덕분에 여러 컨테이너가 같은 이미지를 공유하면서도 독립적으로 파일을 수정할 수 있습니다.
</details>

### 질문 4: 이미지 태그 vs Digest
프로덕션 환경에서 nginx:latest 대신 digest를 사용해야 하는 이유는?

<details>
<summary>정답 보기</summary>

**태그의 문제점**:
- \`nginx:latest\`는 언제든 다른 이미지를 가리킬 수 있음
- 업스트림에서 이미지가 업데이트되면 태그는 같지만 내용이 다름
- 배포 재현성 없음 (어제와 오늘 같은 태그가 다른 이미지)

**Digest의 장점**:
- \`nginx@sha256:abc123...\`는 절대 변경되지 않음
- 해시값이 내용을 고유하게 식별
- 배포 재현성 보장 (같은 digest = 같은 이미지)
- 보안 (중간자 공격으로 이미지 변조 감지)

프로덕션에서는 특정 버전 태그(\`nginx:1.25.3-alpine\`) 또는 digest를 사용하세요.
</details>

### 질문 5: containerd-shim
containerd-shim의 역할과 존재 이유를 설명하세요.

<details>
<summary>정답 보기</summary>

**containerd-shim의 역할**:
1. containerd와 실제 컨테이너 프로세스 사이의 중간자
2. 각 컨테이너마다 하나의 shim 프로세스 존재
3. 컨테이너의 STDIO 처리
4. 컨테이너 종료 상태 보고

**존재 이유**:
1. **런타임 업그레이드 안전성**: containerd를 재시작해도 컨테이너 계속 실행
2. **프로세스 분리**: containerd가 죽어도 컨테이너 유지
3. **리소스 격리**: 각 컨테이너 독립적 관리
4. **daemonless 컨테이너**: runc가 종료되어도 컨테이너 실행 유지

프로덕션에서 containerd 업그레이드 시 컨테이너 다운타임 없이 진행할 수 있는 이유입니다.
</details>

### 질문 6: CRI
Kubernetes가 CRI를 도입한 이유와 CRI가 해결한 문제를 설명하세요.

<details>
<summary>정답 보기</summary>

**CRI 도입 전 문제**:
- Docker 지원 코드가 kubelet에 하드코딩
- 새 런타임(rkt, containerd) 지원하려면 kubelet 수정 필요
- 런타임마다 다른 인터페이스, 유지보수 어려움

**CRI가 해결한 문제**:
1. **표준화된 인터페이스**: 모든 런타임이 같은 gRPC API 구현
2. **런타임 교체 용이**: kubelet 수정 없이 런타임 변경 가능
3. **유지보수 간소화**: 런타임 개발자가 CRI만 구현하면 됨
4. **생태계 다양화**: containerd, CRI-O 등 다양한 런타임 등장

CRI 덕분에 Kubernetes는 런타임에 구애받지 않고 발전할 수 있게 되었습니다.
</details>

### 질문 7: 프록시 레지스트리
폐쇄망 환경에서 프록시 레지스트리가 필요한 이유와 동작 방식을 설명하세요.

<details>
<summary>정답 보기</summary>

**필요한 이유**:
1. 폐쇄망에서 외부 레지스트리(docker.io, quay.io) 접근 불가
2. 각 노드가 독립적으로 이미지 다운로드하면 비효율
3. 네트워크 대역폭 절약 필요
4. 오프라인 환경에서도 배포 가능해야 함

**동작 방식 (Pull-through Cache)**:
1. 클라이언트가 프록시 레지스트리에 이미지 요청
2. 프록시가 로컬 캐시 확인
3. 캐시 hit: 즉시 응답 (오프라인 가능)
4. 캐시 miss: 원본에서 다운로드 → 캐시 저장 → 응답
5. 이후 같은 이미지 요청: 캐시에서 응답

containerd의 \`registry.mirrors\` 설정으로 프록시를 사용하도록 구성합니다.
</details>

### 질문 8: 이미지 레이어 최적화
Dockerfile 작성 시 레이어를 최적화하는 방법 3가지를 설명하세요.

<details>
<summary>정답 보기</summary>

**1. RUN 명령어 합치기**:
\`\`\`dockerfile
# Bad: 4개 레이어
RUN apt-get update
RUN apt-get install -y nginx
RUN apt-get clean
RUN rm -rf /var/lib/apt/lists/*

# Good: 1개 레이어
RUN apt-get update && \\
    apt-get install -y nginx && \\
    apt-get clean && \\
    rm -rf /var/lib/apt/lists/*
\`\`\`

**2. 캐시 친화적 순서**:
\`\`\`dockerfile
# 변경 빈도 낮은 것 먼저
COPY package.json package-lock.json ./
RUN npm install
# 변경 빈도 높은 것 나중에
COPY src/ ./src/
\`\`\`

**3. 멀티스테이지 빌드**:
\`\`\`dockerfile
# 빌드 스테이지
FROM golang:1.21 AS builder
RUN go build -o app

# 런타임 스테이지 (빌드 도구 제외)
FROM alpine:3.18
COPY --from=builder /app /app
\`\`\`
</details>

### 질문 9: 컨테이너 격리 한계
컨테이너가 VM에 비해 격리 수준이 낮은 이유를 설명하세요.

<details>
<summary>정답 보기</summary>

**VM의 격리**:
- 하드웨어 수준 격리 (하이퍼바이저)
- 각 VM에 독립된 커널
- 커널 취약점이 한 VM에만 영향

**컨테이너의 격리**:
- 프로세스 수준 격리 (네임스페이스, cgroups)
- 호스트 커널 공유
- 커널 취약점이 모든 컨테이너에 영향

**보안 강화 방법**:
1. Seccomp: 시스템 콜 필터링
2. AppArmor/SELinux: 필수 접근 제어
3. gVisor: 커널 syscall 필터링
4. Kata Containers: 경량 VM 기반 격리
5. 루트리스 컨테이너: 비특권 사용자로 실행
</details>

### 질문 10: 실제 트러블슈팅
Pod가 \`ImagePullBackOff\` 상태일 때 확인해야 할 항목들을 순서대로 나열하세요.

<details>
<summary>정답 보기</summary>

**트러블슈팅 순서**:

1. **이벤트 확인**:
\`\`\`bash
kubectl describe pod <pod-name>
# Events 섹션에서 오류 메시지 확인
\`\`\`

2. **이미지 이름 확인**:
\`\`\`bash
# 오타, 태그 존재 여부
skopeo inspect docker://<image-name>
\`\`\`

3. **레지스트리 접근 확인**:
\`\`\`bash
# 네트워크 연결
curl -v https://registry-url/v2/
# DNS 확인
nslookup registry-url
\`\`\`

4. **인증 확인 (private registry)**:
\`\`\`bash
# Secret 존재 확인
kubectl get secret <pull-secret> -o yaml
# Pod에 imagePullSecrets 설정 확인
\`\`\`

5. **containerd 설정 확인**:
\`\`\`bash
# 미러/프록시 설정
cat /etc/containerd/config.toml | grep -A 10 "registry"
\`\`\`

6. **containerd 로그 확인**:
\`\`\`bash
journalctl -u containerd -f
\`\`\`
</details>

---

## 다음 단계

이 장에서 컨테이너의 내부 동작을 이해했습니다. 다음 장에서는 **네트워크 기초**를 학습합니다:

- OSI 7계층 모델과 TCP/IP
- Linux 가상 네트워크 디바이스 (veth, bridge, TUN/TAP)
- 네트워크 네임스페이스와 컨테이너 네트워킹
- VXLAN 오버레이 네트워크
- iptables와 netfilter

컨테이너 네트워킹을 이해하면 Kubernetes의 Service, Ingress, NetworkPolicy가 어떻게 동작하는지 깊이 이해할 수 있습니다.

---

## 참고 자료

### 공식 문서

- [OCI Image Specification](https://github.com/opencontainers/image-spec)
- [OCI Runtime Specification](https://github.com/opencontainers/runtime-spec)
- [OCI Distribution Specification](https://github.com/opencontainers/distribution-spec)
- [containerd Documentation](https://containerd.io/docs/)
- [Kubernetes CRI Documentation](https://kubernetes.io/docs/concepts/architecture/cri/)

### 심화 학습

- [How containers work (Julia Evans)](https://jvns.ca/blog/2020/04/27/new-zine-how-containers-work/)
- [What is a container, REALLY?](https://www.youtube.com/watch?v=8fi7uSYlOdc) - Liz Rice 발표
- [containerd Deep Dive](https://www.youtube.com/watch?v=UUDDCetB7_A) - KubeCon 발표
- [The almighty pause container](https://www.ianlewis.org/en/almighty-pause-container) - Ian Lewis

### 도구

- [crictl](https://github.com/kubernetes-sigs/cri-tools) - CRI CLI 도구
- [skopeo](https://github.com/containers/skopeo) - 이미지 검사/복사 도구
- [dive](https://github.com/wagoodman/dive) - 이미지 레이어 탐색 도구
- [nerdctl](https://github.com/containerd/nerdctl) - containerd용 Docker 호환 CLI
